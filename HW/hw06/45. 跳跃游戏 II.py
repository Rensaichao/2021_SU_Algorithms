class Solution:
    def jump(self, nums: List[int]) -> int:
        """
            方法二：动态规划
            # 思路：我们知道最后一个点前面可能会有很多个点能够一步到达最后一个点。也就是f[n-1]可以从f[n-2],f[n-3]....f[n-k]一步走到n-1这个位置, 但我们的目标是找最短的那一个，也就是有 f[n - 1] = min(f[n - k],...,f[n - 3],f[n - 2]) + 1f[n−1]=min(f[n−k],...,f[n−3],f[n−2])+1。 然后我们再来考虑集合 f[n - k],...,f[n - 3],f[n - 2]f[n−k],...,f[n−3],f[n−2] 有何特性。不然发现其实必然有 f[n - k] <= ...<= f[n - 3] <= f[n - 2]f[n−k]<=...<=f[n−3]<=f[n−2]。举个🌰，比如我经过至少 5 步到达第 ii 个点，那么必然不可能出现使用步数少于 5 步就能达到第 i + 1i+1 个点的情况。到达第 i + 1i+1 个点的至少步数必然是 5 步或者 6 步。搞清楚性质之后，再回头看我们的状态定义：f[i] 为到达第 i 个位置所需要的最少步数。因此当我们要求某一个 f[i]f[i] 的时候，我们需要找到最早能够经过一步到达 ii 点的 jj 点。即有状态转移方程：f[i] = f[j] + 1f[i]=f[j]+1。也就是我们每次都贪心的取离 i 点最远的点 j 来更新 f[i]。而这个找 j 的过程可以使用双指针来找。定义两个指针，l和r，若l+nums[l]<r那么说明不能从这一步跳到，就要l++。 如果能跳到，ans[r]就等与ans[l+1]然后r++看看下面这个l能不能够跳到。
            # 其实这个思路就是一个「双指针 + 贪心 + 动态规划」的一个解法。
        """
        l, r = 0, 1
        n = len(nums)
        dp = [0]*(n)
        while r < n:
            while l + nums[l] < r:
                l+=1
            dp[r] = dp[l]+1
            r += 1
        print(dp)
        return dp[n-1]