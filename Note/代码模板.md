# 代码模板

## 第 1 周 第2课

### [前缀和、数组计数代码模板](https://shimo.im/docs/R8SmKYMs7KsfK45Y) – LeetCode 1248 统计优美子数组

#### C++ 代码模板

```c++
// C/C++
// LeetCode 1248 统计优美子数组
class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        // 开头插入一个0，转化成下标1~n
        int n = nums.size();
        nums.insert(nums.begin(), 0);
        // 前缀和，下标0~n
        vector<int> sum(n + 1, 0);
        for (int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + nums[i] % 2;
        // 计数，下标0~n
        vector<int> count(n + 1, 0);
        for (int i = 0; i <= n; i++)
            count[sum[i]]++;
        int ans = 0;
        for (int i = 0; i < nums.size(); i++)
            ans += sum[i] >= k ? count[sum[i] - k] : 0;
        return ans;
    }
};
```

####  Python 代码模板

```python
# Python
# LeetCode 1248 统计优美子数组
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        nums = [0] + nums
        s = [0] * len(nums)
        for i in range(1, len(nums)):
            s[i] = s[i - 1] + nums[i] % 2
        count = [0] * len(s)
        for i in range(len(s)):
            count[s[i]] += 1
        ans = 0
        for i in range(1, len(s)):
            if s[i] - k >= 0:
                ans += count[s[i] - k]
        return ans
```

#### Java 代码模板

```java
// Java
// LeetCode 1248 统计优美子数组
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        int n = nums.length;
        int[] s = new int[n + 1]; // 0~n
        int[] count = new int[n + 1];
        // s[0] = 0;
        count[s[0]]++;
        for (int i = 1; i <= n; i++) {
            s[i] = s[i - 1] + nums[i - 1] % 2;
            count[s[i]]++;
        }

        int ans = 0;
        for (int i = 1; i <= n; i++) {
            // s[i] - s[j] = k, 求j的数量
            // s[j] = s[i] - k
            if (s[i] - k >= 0) {
                ans += count[s[i] - k];
            }
        }
        return ans;
    }
}
```

####  JavaScript 代码模板

```javascript
// JavaScript
// LeetCode 1248 统计优美子数组
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numberOfSubarrays = function(nums, k) {
    var n = nums.length;
    nums.unshift(0);
    var s = new Array(n + 1).fill(0); // 下标0~n
    for (let i = 1; i <= n; i++)
        s[i] = s[i - 1] + nums[i] % 2;
    
    var count = new Array(n + 1).fill(0); // 下标0~n
    for (let i = 0; i <= n; i++)
        count[s[i]] += 1;

    // s[i] + s[j] = k
    // Home many s[j] equals s[i] - k?
    var ans = 0;
    for (let i = 1; i <= n; i++)
        if (s[i] - k >= 0) ans += count[s[i] - k];
    return ans;
};
```

#### Golang 代码模板

```go
func numberOfSubarrays(nums []int, k int) int {
    n := len(nums)
    s := make([]int, n+1)
    cnt := make([]int, n+1)
    ans := 0
    
    cnt[s[0]]++;
    for i := 1; i <= n; i++ {
      s[i] = s[i-1] + nums[i-1]%2;
      cnt[s[i]]++;
    }
    
    for i := 1; i <= n; i++ {
      if s[i] >= k {
        ans += cnt[s[i]-k]
      }
    }

    return ans
}
```



### [二维前缀和代码模板](https://shimo.im/docs/vufyatCV6Vo1imT9) – LeetCode 304 二维区域和检索 - 矩阵不可变

#### C++ 代码模板

```c++
// C/C++
// LeetCode 304 二维区域和检索 - 矩阵不可变
class NumMatrix {
public:
    NumMatrix(vector<vector<int>>& matrix) {
        sum.clear();
        for (int i = 0; i < matrix.size(); i++) {
            sum.push_back({});
            for (int j = 0; j < matrix[i].size(); j++)
                sum[i].push_back(get_sum(i - 1, j) + get_sum(i, j - 1) - get_sum(i - 1, j - 1) + matrix[i][j]);
        }
    }
    
    int sumRegion(int row1, int col1, int row2, int col2) {
        return get_sum(row2, col2) - get_sum(row1 - 1, col2) - get_sum(row2, col1 - 1) + get_sum(row1 - 1, col1 - 1);
    }

private:
    int get_sum(int i, int j) {
        if (i >= 0 && j >= 0) return sum[i][j];
        return 0;
    }

    vector<vector<int>> sum;
};
```

#### Python 代码模板

```python
# Python
# LeetCode 304 二维区域和检索 - 矩阵不可变
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.sum = [[0] * len(matrix[0]) for i in range(len(matrix))]
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                self.sum[i][j] = self.getSum(i - 1, j) + self.getSum(i, j - 1) - self.getSum(i - 1, j - 1) + matrix[i][j]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.getSum(row2, col2) - self.getSum(row1 - 1, col2) - self.getSum(row2, col1 - 1) + self.getSum(row1 - 1, col1 - 1)

    def getSum(self, i, j):
        return self.sum[i][j] if i >= 0 and j >= 0 else 0
```

#### Java 代码模板

```java
// Java
// LeetCode 304 二维区域和检索 - 矩阵不可变
class NumMatrix {

    public NumMatrix(int[][] matrix) {
        sum = new int[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++)
            for (int j = 0; j < matrix[i].length; j++)
                sum[i][j] = get_sum(i - 1, j) + get_sum(i, j - 1) - get_sum(i - 1, j - 1) + matrix[i][j];
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return get_sum(row2, col2) - get_sum(row1 - 1, col2) - get_sum(row2, col1 - 1) + get_sum(row1 - 1, col1 - 1);
    }

    private int get_sum(int i, int j) {
        if (i >= 0 && j >= 0) return sum[i][j];
        return 0;
    }

    private int[][] sum;
}
```

####  JavaScript 代码模板

```javascript
// JavaScript
// LeetCode 304 二维区域和检索 - 矩阵不可变
/**
 * @param {number[][]} matrix
 */
var NumMatrix = function(matrix) {
    // 二维数组初始化，全部清零
    this.sum = new Array(matrix.length).fill(0).map(() => new Array(matrix[0].length).fill(0));
    // 二维前缀和
    for (let i = 0; i < matrix.length; i++)
        for (let j = 0; j < matrix[i].length; j++)
            this.sum[i][j] = this.getSum(i - 1, j) + this.getSum(i, j - 1) - this.getSum(i - 1, j - 1) + matrix[i][j];
};

/** 
 * @param {number} row1 
 * @param {number} col1 
 * @param {number} row2 
 * @param {number} col2
 * @return {number}
 */
NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
    return this.getSum(row2, col2) - this.getSum(row1 - 1, col2) - this.getSum(row2, col1 - 1) + this.getSum(row1 - 1, col1 - 1);
};

NumMatrix.prototype.getSum = function(i, j) {
    if (i >= 0 && j >= 0) return this.sum[i][j];
    return 0;
}
```
#### Golang 代码模板

```go
 
type NumMatrix struct {
    sums [][]int
}

func Constructor(matrix [][]int) NumMatrix {
    m := len(matrix)
    if m == 0 {
        return NumMatrix{}
    }
    n := len(matrix[0])
    sums := make([][]int, m+1)
    sums[0] = make([]int, n+1)
    for i, row := range matrix {
        sums[i+1] = make([]int, n+1)
        for j, v := range row {
            sums[i+1][j+1] = sums[i+1][j] + sums[i][j+1] - sums[i][j] + v
        }
    }
    return NumMatrix{sums}
}

func (nm *NumMatrix) SumRegion(row1, col1, row2, col2 int) int {
    return nm.sums[row2+1][col2+1] - nm.sums[row1][col2+1] - nm.sums[row2+1][col1] + nm.sums[row1][col1]
}

```


###  [差分代码模板](https://shimo.im/docs/IuXdO0ink38n0gqv) – LeetCode 1109 航班预订统计

#### C++ 代码模板

```c++
// C/C++
// LeetCode 1109 航班预订统计
class Solution {
public:
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        vector<int> delta(n + 2, 0);  // 差分要开0~n+1
        for (auto& booking : bookings) {
            int fir = booking[0];
            int last = booking[1];
            int seats = booking[2];
            // 差分模板
            delta[fir] += seats;
            delta[last + 1] -= seats;
        }
        vector<int> a(n + 1, 0);  // 0~n

        // 1~n
        for (int i = 1; i <= n; i++) a[i] = a[i - 1] + delta[i];
        
        // 0~n-1
        for (int i = 1; i <= n; i++) a[i - 1] = a[i];
        a.pop_back();
        return a;
    }
};

// 任何对于区间的操作，可以转化为两个关键点（事件）
// 事件的影响从l开始，在r+1处消失
// 累加影响得到答案
// l +d    r+1   -d
   1  2  3  4  5
  10    -10
     20    -20
     25          (-25)
  10 45 -10 -20 0
  10 55 45  25 25
```

#### Python 代码模板

```python
# Python
# LeetCode 1109 航班预订统计
class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        delta = [0] * (n + 2);  # 差分要开0~n+1
        for booking in bookings:
            fir = booking[0]
            last = booking[1]
            seats = booking[2]
            # 差分模板
            delta[fir] += seats
            delta[last + 1] -= seats

        a = [0] * (n + 1)  # 0~n
        # 1~n
        for i in range(1, n + 1):
            a[i] = a[i - 1] + delta[i]
        # 0~n-1
        return a[1:]
```

#### Java 代码模板

```java
// Java
// LeetCode 1109 航班预订统计
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] delta = new int[n + 2];  // 差分要开0~n+1
        Arrays.fill(delta, 0);
        for (int[] booking : bookings) {
            int fir = booking[0];
            int last = booking[1];
            int seats = booking[2];
            // 差分模板
            delta[fir] += seats;
            delta[last + 1] -= seats;
        }

        int[] a = new int[n + 1]; // 0~n
        a[0] = 0;
        // 1~n
        for (int i = 1; i <= n; i++) a[i] = a[i - 1] + delta[i];
        
        // 0~n-1
        int[] ans = new int[n];
        for (int i = 1; i <= n; i++) ans[i - 1] = a[i];
        return ans;
    }
}
```

#### JavaScript 代码模板

```javascript
// JavaScript
// LeetCode 1109 航班预订统计
/**
 * @param {number[][]} bookings
 * @param {number} n
 * @return {number[]}
 */
var corpFlightBookings = function(bookings, n) {
    var delta = new Array(n + 2).fill(0);  // 差分要开0~n+1
    for (const booking of bookings) {
        let fir = booking[0];
        let last = booking[1];
        let seats = booking[2];
        // 差分模板
        delta[fir] += seats;
        delta[last + 1] -= seats;
    }

    var a = new Array(n + 1).fill(0); // 0~n
    // 1~n
    for (let i = 1; i <= n; i++) a[i] = a[i - 1] + delta[i];
    // 0~n-1
    a.shift();
    return a;
};
```

#### Golang 代码模板

```go
func corpFlightBookings(bookings [][]int, n int) []int {
    arr := make([]int , n+2)
    for _, book := range bookings {
        arr[book[0]] += book[2]
        arr[book[1]+1] -= book[2]
    }
    for i := 1; i <= n; i++ {
        arr[i] += arr[i-1]
    }
    return arr[1:n+1]
}
```



### [双指针夹逼模板](https://shimo.im/docs/i47HkK5OXbQmvloN) – LeetCode 167 两数之和 - 输入有序数组

#### C++ 代码模板

```c++
// C/C++
// LeetCode 167 两数之和 - 输入有序数组
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int j = numbers.size() - 1;
        for (int i = 0; i < numbers.size(); i++) {
            while (i < j && numbers[i] + numbers[j] > target) j--;
            if (i < j && numbers[i] + numbers[j] == target) {
                return {i + 1, j + 1};
            }
        }
        return {};
    }
/*
    for i = 0 ~ n - 1
        for j = i + 1 ~ n - 1
            if (numbers[i] + numbers[j] == target)
                return ...

    固定i，找到j使得 numbers[j] = target - numbers[i]
    移动i，j怎么变？
    i增大，j单调减小
*/
};
```

#### Python 代码模板

```python
# Python
# LeetCode 167 两数之和 - 输入有序数组
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        j = len(numbers) - 1
        for i in range(len(numbers)):
            while i < j and numbers[i] + numbers[j] > target:
                j -= 1
            if i < j and numbers[i] + numbers[j] == target:
                return [i + 1, j + 1]
        return
```

#### Java 代码模板

```java
// Java
// LeetCode 167 两数之和 - 输入有序数组
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int j = numbers.length - 1;
        for (int i = 0; i < numbers.length; i++) {
            while (i < j && numbers[i] + numbers[j] > target) j--;
            if (i < j && numbers[i] + numbers[j] == target) {
                return new int[]{i + 1, j + 1};
            }
        }
        return null;
    }
}
```

#### JavaScript 代码模板

```javascript
// JavaScript
// LeetCode 167 两数之和 - 输入有序数组
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    let j = numbers.length - 1;
    for (let i = 0; i < numbers.length; i++) {
        while (i < j && numbers[i] + numbers[j] > target) j--;
        if (i < j && numbers[i] + numbers[j] == target) {
            return [i + 1, j + 1];
        }
    }
    return [];
};
```

#### Golang 代码模板

```go
// Go
// LeetCode 167 两数之和 - 输入有序数组
func twoSum(numbers []int, target int) []int {
	j := len(numbers) - 1
	for i := range numbers {
		for i < j && numbers[i] + numbers[j] > target {
			j--
		}
        if (i < j && numbers[i] + numbers[j] == target) {
            return []int{i + 1, j + 1}
        }
	}
    return nil
}
```



### [单调栈模板](https://shimo.im/docs/9ti9O9f6q2kJXGTN) – LeetCode 84 柱状图中最大的矩形

#### C++ 代码模板 

```c++
// C/C++
// LeetCode 84 柱状图中最大的矩形
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(0); // 帮助我们在最后把栈清空
        stack<Rect> s;
        int ans = 0;
        // 每个柱子入栈、出栈各一次，2n=O(n)
        // 第一步：for 每个元素
        for (int h : heights) {
            int accumulated_width = 0;
            // 第二步：while (栈顶不满足高度单调性) 累加宽度，出栈
            while (!s.empty() && s.top().height >= h) {
                accumulated_width += s.top().width;
                ans = max(ans, accumulated_width * s.top().height);
                s.pop();
            }
            // 第三步：新元素入栈
            s.push({h, accumulated_width + 1});
        }
        return ans;
    }

private:
    struct Rect {
        int height;
        int width;
    };
};
```

#### Python 代码模板

```python
# Python
# LeetCode 84 柱状图中最大的矩形
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(0) # 帮助我们在最后把栈清空
        stack = [] # [[height, width], ...]
        ans = 0
        # 每个柱子入栈、出栈各一次，2n=O(n)
        # 第一步：for 每个元素
        for h in heights:
            accumulated_width = 0
            # 第二步：while (栈顶不满足高度单调性) 累加宽度，出栈
            while stack and stack[-1][0] >= h:
                accumulated_width += stack[-1][1]
                ans = max(ans, accumulated_width * stack[-1][0])
                stack.pop()
            # 第三步：新元素入栈
            stack.append([h, accumulated_width + 1])
        return ans
```

#### Java 代码模板

```java
// Java
// LeetCode 84 柱状图中最大的矩形
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] heights_with_zero = Arrays.copyOf(heights, n + 1);
        heights_with_zero[n] = 0; // 帮助我们在最后把栈清空
        Stack<Rect> s = new Stack<Rect>();
        int ans = 0;
        // 每个柱子入栈、出栈各一次，2n=O(n)
        // 第一步：for 每个元素
        for (Integer h : heights_with_zero) {
            int accumulated_width = 0;
            // 第二步：while (栈顶不满足高度单调性) 累加宽度，出栈
            while (!s.empty() && s.peek().height >= h) {
                accumulated_width += s.peek().width;
                ans = Math.max(ans, accumulated_width * s.peek().height);
                s.pop();
            }
            // 第三步：新元素入栈
            Rect rect = new Rect();
            rect.height = h;
            rect.width = accumulated_width + 1;
            s.push(rect);
        }
        return ans;
    }

    private class Rect {
        public int height;
        public int width;
    };
}
```

#### JavaScript 代码模板

```javascript
// JavaScript
// LeetCode 84 柱状图中最大的矩形
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
    heights.push(0) // 帮助我们在最后把栈清空
    var stack = [] // [[height, width], ...]
    var ans = 0
    // 每个柱子入栈、出栈各一次，2n=O(n)
    // 第一步：for 每个元素
    for (const h of heights) {
        let accumulated_width = 0
        // 第二步：while (栈顶不满足高度单调性) 累加宽度，出栈
        while (stack.length > 0 && stack[stack.length - 1][0] >= h) {
            accumulated_width += stack[stack.length - 1][1]
            ans = Math.max(ans, accumulated_width * stack[stack.length - 1][0])
            stack.pop()
        }
        // 第三步：新元素入栈
        stack.push([h, accumulated_width + 1])
    }
    return ans
};
```

#### Golang 代码模板

```go
// Go
// LeetCode 84 柱状图中最大的矩形

type Rect struct {
	Height int
	Width int
}

func largestRectangleArea(heights []int) int {
    heights = append(heights, 0) // 帮助我们在最后把栈清空
	var s []Rect
	ans := 0
    // 每个柱子入栈、出栈各一次，2n=O(n)
    // 第一步：for 每个元素
    for _, h := range heights {
		accumulatedWidth := 0
        // 第二步：while (栈顶不满足高度单调性) 累加宽度，出栈
        for len(s) > 0 && s[len(s) - 1].Height >= h {
            accumulatedWidth += s[len(s) - 1].Width;
			if ans < accumulatedWidth * s[len(s) - 1].Height {
				ans = accumulatedWidth * s[len(s) - 1].Height
			}
            s = s[: len(s) - 1]
        }
        // 第三步：新元素入栈
		s = append(s, Rect{h, accumulatedWidth + 1})
	}
    return ans
}
```



### [单调队列模板](https://shimo.im/docs/Ux4PvQhQy6kcT26M) – LeetCode 239 滑动窗口最大值

#### C++ 代码模板

```c++
// C/C++
// LeetCode 239 滑动窗口最大值
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> ans;
        // 双端队列，存下标（代表时间）
        deque<int> q;
        for (int i = 0; i < nums.size(); i++) {
            // 保证队头合法性
            while (!q.empty() && q.front() <= i - k) q.pop_front();
            // 维护队列单调性，插入新的选项
            while (!q.empty() && nums[q.back()] <= nums[i]) q.pop_back();
            q.push_back(i);
            // 取队头更新答案
            if (i >= k - 1) ans.push_back(nums[q.front()]);
        }
        return ans;
    }
};
/*
1 3 [-1 -3 5] 3 6 7

时间：expire_time(-1) < expire_time(-3) < expire_time(5)
值大小：-1 < -3 < 5
求max

冗余：一个下标i一个下标j，如果i<j，并且nums[i]<=nums[j]，i是冗余
去除冗余：维护下标（时间）递增、nums递减（>=）的队列
队头最优，随着下标增长，队头expire后，后面的开始逐渐变成最优
*/
```

#### Python 代码模板

```python
# Python
# LeetCode 239 滑动窗口最大值
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []
        # 数组模拟双端队列，存下标（代表时间）
        l, r = 0, -1 # left, right
        q = [0] * len(nums) # left~right（包含两端）存储队列中的元素
        for i in range(len(nums)):
            # 保证队头合法性
            while l <= r and q[l] <= i - k:
                l += 1
            # 维护队列单调性，插入新的选项
            while l <= r and nums[q[r]] <= nums[i]:
                r -= 1
            r += 1
            q[r] = i
            # 取队头更新答案
            if i >= k - 1:
                ans.append(nums[q[l]])
        return ans
```

#### Java 代码模板

```java
// Java
// LeetCode 239 滑动窗口最大值
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        // 双端队列，存下标（代表时间）
        Deque<Integer> q = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            // 保证队头合法性
            while (!q.isEmpty() && q.getFirst() <= i - k) q.removeFirst();
            // 维护队列单调性，插入新的选项
            while (!q.isEmpty() && nums[q.getLast()] <= nums[i]) q.removeLast();
            q.addLast(i);
            // 取队头更新答案
            if (i >= k - 1) ans[i - (k - 1)] = nums[q.getFirst()];
        }
        return ans;
    }
}
```

#### JavaScript 代码模板

```javascript
// JavaScript
// LeetCode 239 滑动窗口最大值
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    var ans = [];
    // 数组模拟双端队列，存下标（代表时间）
    var l = 0, r = -1; // left, right
    var q = []; // left~right（包含两端）存储队列中的元素
    for (let i = 0; i < nums.length; i++) {
        // 保证队头合法性
        while (l <= r && q[l] <= i - k) l++;
        // 维护队列单调性，插入新的选项
        while (l <= r && nums[q[r]] <= nums[i]) r--;
        r++;
        q[r] = i;
        // 取队头更新答案
        if (i >= k - 1) ans.push(nums[q[l]]);
    }
    return ans;
};
```

#### Golang 代码模板

```go
// Go
// LeetCode 239 滑动窗口最大值
func maxSlidingWindow(nums []int, k int) []int {
    var q, ans []int;
    for i := range nums {
        // 保证队头合法性
        for len(q) > 0 && q[0] <= i - k {
			q = q[1:]
		}
        // 维护队列单调性，插入新的选项
        for len(q) > 0 && nums[q[len(q) - 1]] <= nums[i] {
			q = q[: len(q) - 1]
		} 
		q = append(q, i)
        // 取队头更新答案
        if (i >= k - 1) {
			ans = append(ans, nums[q[0]])
		}
    }
    return ans;
}
```





## 第 2 周 第3课

### [ LRU Cache](https://shimo.im/docs/VrZCLACWhc8IoDTH) (第3课)



#### C/C++ 代码模板

```c++
//C/C++

class LRUCache {
public:
    LRUCache(int capacity) : capacity(capacity) {
        head.next = &tail;
        tail.pre = &head;
    }
    
    int get(int key) {
        if (h.find(key) == h.end()) return -1;
        Node* item = h[key];
        removeFromList(item);
        insertToList(item);
        return item->value;
    }
    
    void put(int key, int value) {
        if (h.find(key) == h.end()) {
            Node* item = new Node();
            item->key = key, item->value = value;
            insertToList(item);
            h[key] = item;
        } else {
            Node* item = h[key];
            item->value = value;
            removeFromList(item);
            insertToList(item);
        }
        if (h.size() > capacity) {
            Node* node = tail.pre;
            removeFromList(node);
            h.erase(node->key);
            delete node;
        }
    }

private:
    struct Node {
        int key;
        int value;
        Node* pre;
        Node* next;
    };

    void removeFromList(Node* node) {
        node->pre->next = node->next;
        node->next->pre = node->pre;
    }

    void insertToList(Node* node) {
        head.next->pre = node;
        node->next = head.next;
        head.next = node;
        node->pre = &head;
    }

    int capacity;
    unordered_map<int, Node*> h;
    Node head, tail;
};
```

#### Java代码模板

```java
// Java

public class LRUCache {

    private class Node {
        public int key;
        public int value;
        public Node pre;
        public Node next;
    };
    
    private HashMap<Integer, Node> map;
    // 保护结点
    private Node head;
    private Node tail;
    private int capacity;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<Integer, Node>();
        // 建立带有保护结点的空双向链表
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        if (!this.map.containsKey(key)) return -1;
        Node node = map.get(key);
        // 从链表和map中删掉
        this.removeFromList(node);
        // 重新插入到map、链表头部，维护时间顺序
        this.insertToListHead(node.key, node.value);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (this.map.containsKey(key)) {
            Node node = this.map.get(key);
            // 从链表中删掉
            this.removeFromList(node);
            // 重新插入到头部，维护时间顺序
            this.insertToListHead(key, value);
        } else {
            // 在链表中插入新结点，返回新结点引用
            this.insertToListHead(key, value);
        }
        if (this.map.size() > this.capacity) {
            this.removeFromList(tail.pre);
        }
    }

    private void removeFromList(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
        this.map.remove(node.key);
    }

    private Node insertToListHead(int key, int value) {
        Node node = new Node();
        node.key = key;
        node.value = value;
        // node与head的下一个点之间建立联系
        node.next = head.next;
        head.next.pre = node;
        // node与head之间建立联系
        node.pre = head;
        head.next = node;
        // 建立映射关系
        this.map.put(key, node);
        return node;
    }
}
```

#### Python代码模板

```python
# Python 

class LRUCache(object): 

	def __init__(self, capacity): 
		self.dic = collections.OrderedDict() 
		self.remain = capacity

	def get(self, key): 
		if key not in self.dic: 
			return -1 
		v = self.dic.pop(key) 
		self.dic[key] = v   # key as the newest one 
		return v 

	def put(self, key, value): 
		if key in self.dic: 
			self.dic.pop(key) 
		else: 
			if self.remain > 0: 
				self.remain -= 1 
			else:   # self.dic is full
				self.dic.popitem(last=False) 
		self.dic[key] = value
```

#### JavaScript代码模板

```javascript
// JavaScript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return -1;
    
    let value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else {
      if (this.cache.size >= this.capacity) {
        // Map 中新 set 的元素会放在后面
        let firstKey = this.cache.keys().next();
        this.cache.delete(firstKey.value);
      }
    }
    this.cache.set(key, value);
  }
}
```

#### Golang代码模板

```go
package lru

import (
    "container/list"
    "errors"
)

type LRU struct {
    size      int
    innerList *list.List
    innerMap  map[int]*list.Element
}

type entry struct {
    key   int
    value int
}

func NewLRU(size int) (*LRU, error) {
    if size <= 0 {
        return nil, errors.New("must provide a positive size")
    }
    c := &LRU{
        size:      size,
        innerList: list.New(),
        innerMap:  make(map[int]*list.Element),
    }
    return c, nil
}

func (c *LRU) Get(key int) (int, bool) {
    if e, ok := c.innerMap[key]; ok {
        c.innerList.MoveToFront(e)
        return e.Value.(*entry).value, true
    }
    return -1, false
}

func (c *LRU) Put(key int, value int) (evicted bool) {
    if e, ok := c.innerMap[key]; ok {
        c.innerList.MoveToFront(e)
        e.Value.(*entry).value = value
        return false
    } else {
        e := &entry{key, value}
        ent := c.innerList.PushFront(e)
        c.innerMap[key] = ent

        if c.innerList.Len() > c.size {
            last := c.innerList.Back()
            c.innerList.Remove(last)
            delete(c.innerMap, last.Value.(*entry).key)
            return true
        }
        return false
    }
}

```

### [排列递归模板](https://shimo.im/docs/xTPRw36JTj6DwP8G)

#### Python代码模板

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.nums = nums
        self.ans = []
        self.per = []
        self.n = len(nums)
        self.used = [False] * self.n
        self.find(0)
        return self.ans

    # 依次考虑0,1,...,n-1位置放哪个数  
    # “从还没用过的”数中选一个放在当前位置
    def find(self, index):
        if index == self.n:
            self.ans.append(self.per[:])  # make a copy
            return
        for i in range(self.n):
            if not self.used[i]:
                self.used[i] = True
                self.per.append(self.nums[i])
                self.find(index + 1)
                self.per.pop()
                self.used[i] = False
```
#### JavaScript代码模板

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    var ans = [];
    var s = [];
    var used = [];
    var find = function(index) {
        if (index == nums.length) {
            ans.push(s.slice());
            return;
        }
        for (let i = 0; i < nums.length; i++)
            if (!used[i]) {
                used[i] = true;
                s.push(nums[i]);
                find(index + 1);
                s.pop();
                used[i] = false;
            }
    };
    find(0);
    return ans;
};
```
#### C/C++代码模板

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        used = vector<bool>(nums.size(), false);
        find(nums, 0);
        return ans;
    }

    void find(vector<int>& nums, int count) {
        if (count == nums.size()) {
            ans.push_back(s);
            return;
        }
        for (int i = 0; i < nums.size(); i++)
            if (!used[i]) {
                used[i] = true;
                s.push_back(nums[i]);
                find(nums, count + 1);
                s.pop_back();
                used[i] = false;
            }
    }

private:
    vector<vector<int>> ans;
    vector<int> s;
    vector<bool> used;
};
```
#### Java代码模板

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        n = nums.length;
        num = new int[n];
        for (int i = 0; i < n; i++) num[i] = nums[i];
        used = new boolean[n];
        per = new ArrayList<Integer>();
        ans = new ArrayList<List<Integer>>();
        dfs(0);
        return ans;
    }

    private void dfs(int depth) {
        if (depth == n) {
            ans.add(new ArrayList<Integer>(per));
            return;
        }
        for (int i = 0; i < n; i++) {
            if (used[i]) continue;
            used[i] = true;
            per.add(num[i]);
            dfs(depth + 1);
            per.remove(per.size() - 1);
            used[i] = false;
        }
    }

    private int n;
    private int[] num;
    private boolean[] used;
    private List<Integer> per;
    private List<List<Integer>> ans;
}
```
#### Golang代码模版

```go
func permute(nums []int) [][]int {
	res := [][]int{}

	var find = func(path []int, depth int) {
        if = len(num == depths) {
			tmp := make([]int, len(path))
			copy(tmp ,path)
			res = append(res, tmp)
			return
		}

		for i := 0; i < len(nums); i++ {
			if used[i] {continue;}
            used[i] = true;
			path = append(path, nums[i])
			find(path,epth+1)
			path = path[:len(path) - 1]
            used[i] = false;
		}

	}
	find([]int{}, 0)
	return res
}
```


### [组合递归模板](https://shimo.im/docs/DcDqJ3yKyr98vThh)
#### Java代码模板

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        ans = new ArrayList<List<Integer>>();
        s = new ArrayList<Integer>();
        this.n = n;
        this.k = k;
        findSubsets(1);
        return ans;
    }

    private void findSubsets(int index) {
        // 已经选了超过k个，
        // 或者把剩下的全选上也不够k个，退出
        if (s.size() > k || s.size() + n - index + 1 < k) return;
        if (index == n + 1) {
            ans.add(new ArrayList<Integer>(s));
            return;
        }
        findSubsets(index + 1);
        s.add(index);
        findSubsets(index + 1);
        s.remove(s.size() - 1);
    }

    private List<List<Integer>> ans;
    private List<Integer> s;
    private int n;
    private int k;
}
```
#### JavaScript代码模板

```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
    var ans = []
    var s = []
    var findSubsets = function(index) {
        // 已经选了超过k个，
        // 或者把剩下的全选上也不够k个，退出
        if (s.length > k || s.length + n - index + 1 < k) return;
        if (index == n + 1) {
            ans.push(s.slice())
            return
        }
        findSubsets(index + 1)
        s.push(index)
        findSubsets(index + 1)
        s.pop()
    }
    findSubsets(1)
    return ans
};
```
#### Python代码模板

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        self.ans = []
        self.s = []
        self.n = n
        self.k = k
        self.findSubsets(1)
        return self.ans
    
    def findSubsets(self, index):
        # 已经选了超过k个，
        # 或者把剩下的全选上也不够k个，退出
        if len(self.s) > self.k or len(self.s) + self.n - index + 1 < self.k:
            return
        if index == self.n + 1:
            self.ans.append(self.s[:]) # make a copy
            return
        self.findSubsets(index + 1)
        self.s.append(index)
        self.findSubsets(index + 1)
        self.s.pop()
```
#### C/C++代码模板

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        this->n = n;
        this->k = k;
        findSubsets(1);
        return ans;
    }

    void findSubsets(int index) {
        // 已经选了超过k个，
        // 或者把剩下的全选上也不够k个，退出
        if (s.size() > k || s.size() + n - index + 1 < k) return;
        if (index == n + 1) {
            ans.push_back(s);
            return;
        }
        findSubsets(index + 1);
        s.push_back(index);
        findSubsets(index + 1);
        s.pop_back();
    }

private:
    vector<vector<int>> ans;
    vector<int> s;
    int n;
    int k;
};
```

#### Golang代码模板

```go
func combine(n int, k int) [][]int {
    ans := [][]int{}
    s := []int{}

    var findSubsets func(index int)
    findSubsets = func(index int) {
        if len(s) > k || len(s) + (n-index+1) < k{
            return 
        }
        if index == n + 1 {
            tmp := make([]int, k)
            copy(tmp, s)
            ans = append(ans, tmp)
            return
        }
        findSubsets(index+1)
        s = append(s, index)
        findSubsets(index+1)
        s = s[:len(s)-1]
    }

    findSubsets(1)
    return ans
}

```


### [递归代码模板](https://shimo.im/docs/LiOznSPZl1cCUweS)

#### Python 代码模板

```
# Python
def recursion(level, param1, param2, ...): 
    # recursion terminator 
    if level > MAX_LEVEL: 
	   process_result 
	   return 

    # process logic in current level 
    process(level, data...) 

    # drill down 
    self.recursion(level + 1, p1, ...) 

    # reverse the current level status if needed
```

#### Java 代码模板

```
// Java
public void recur(int level, int param) { 

  // terminator 
  if (level > MAX_LEVEL) { 
    // process result 
    return; 
  }

  // process current logic 
  process(level, param); 

  // drill down 
  recur( level: level + 1, newParam); 

  // restore current status 
 
}
```

#### C++ 代码模板

```c++
// C/C++
void recursion(int level, int param) { 
  // recursion terminator
  if (level > MAX_LEVEL) { 
    // process result 
    return ; 
  }

  // process current logic 
  process(level, param);

  // drill down 
  recursion(level + 1, param);

  // reverse the current level status if needed
}
```

#### JavaScript 代码模板

```javascript
// JavaScript
const recursion = (level, params) =>{
   // recursion terminator
   if(level > MAX_LEVEL){
     process_result
     return 
   }
   // process current level
   process(level, params)
   //drill down
   recursion(level+1, params)
   //clean current level status if needed
   
}
```

#### Golang 代码模版

```go
// Go
func Recursion (level int, param int)  {
  // terminator
  if (level > MAX_LEVEL) {
    return
  }
  // proccess current level
  Process(level, param)
  // drill down
  Recursion(level+1, param)
  // clean current level status if needed
}
```



### [分治代码模板](https://shimo.im/docs/zYiSxKSX3gUfk5If)
#### Python代码模板

```python
# Python
def divide_conquer(problem, param1, param2, ...): 
  # recursion terminator 
  if problem is None: 
	print_result 
	return 

  # prepare data 
  data = prepare_data(problem) 
  subproblems = split_problem(problem, data) 

  # conquer subproblems 
  subresult1 = self.divide_conquer(subproblems[0], p1, ...) 
  subresult2 = self.divide_conquer(subproblems[1], p1, ...) 
  subresult3 = self.divide_conquer(subproblems[2], p1, ...) 
  …

  # process and generate the final result 
  result = process_result(subresult1, subresult2, subresult3, …)
	
  # revert the current level states
```

#### C/C++代码模板

```c++
C/C++
int divide_conquer(Problem *problem, int params) {
  // recursion terminator
  if (problem == nullptr) {
    process_result
    return return_result;
  } 

  // process current problem
  subproblems = split_problem(problem, data)
  subresult1 = divide_conquer(subproblem[0], p1)
  subresult2 = divide_conquer(subproblem[1], p1)
  subresult3 = divide_conquer(subproblem[2], p1)
  ...

  // merge
  result = process_result(subresult1, subresult2, subresult3)
  // revert the current level status
 
  return 0;
}
```

#### JavaScript代码模板

```javascript
//Javascript
const divide_conquer = (problem, params) => {

  // recursion terminator

  if (problem == null) {

    process_result

    return

  } 

  // process current problem

  subproblems = split_problem(problem, data)

  subresult1 = divide_conquer(subproblem[0], p1)

  subresult2 = divide_conquer(subproblem[1], p1)

  subresult3 = divide_conquer(subproblem[2], p1)

  ...

  // merge

  result = process_result(subresult1, subresult2, subresult3)

  // revert the current level status

}
```

#### Java代码模板

```plain
Java

private static int divide_conquer(Problem problem, ) {
  
  if (problem == NULL) {
    int res = process_last_result();
    return res;     
  }

  subProblems = split_problem(problem)
  
  res0 = divide_conquer(subProblems[0])
  res1 = divide_conquer(subProblems[1])
  
  result = process_result(res0, res1);
  
  return result;
}
```

#### Golang代码模板

```go
func divide_conquer(Problem *problem) int {
  if (problem == nil) {
    res := process_last_result();
    return res;
  }
  
  subProblems := split_problems(problem)
  
  res0 := divide_conquer(subProblems[0])
  res1 := divide_conquer(subProblems[1])
  
  result := process_result(res0, res1)
  
  return result
}
```


### [子集递归模板](https://shimo.im/docs/yrVQw6rjdVYVJyrH)
#### C/C++代码模板

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        findSubsets(nums, 0);
        return ans;
    }

    void findSubsets(vector<int>& nums, int index) {
        if (index == nums.size()) {
            ans.push_back(s);
            return;
        }
        findSubsets(nums, index + 1);
        s.push_back(nums[index]);
        findSubsets(nums, index + 1);
        s.pop_back();
    }

private:
    vector<vector<int>> ans;
    vector<int> s;
};
```

#### Java代码模板

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        ans = new ArrayList<List<Integer>>();
        s = new ArrayList<Integer>();
        findSubsets(nums, 0);
        return ans;
    }

    private void findSubsets(int[] nums, int index) {
        if (index == nums.length) {
            ans.add(new ArrayList<Integer>(s));
            return;
        }
        findSubsets(nums, index + 1);
        s.add(nums[index]);
        findSubsets(nums, index + 1);
        s.remove(s.size() - 1);
    }

    private List<List<Integer>> ans;
    private List<Integer> s;
}
```

#### Python代码模板

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        self.s = []
        self.n = len(nums)
        self.findSubsets(nums, 0)
        return self.ans
    
    def findSubsets(self, nums, index):
        if index == self.n:
            self.ans.append(self.s[:]) # make a copy
            return
        self.findSubsets(nums, index + 1)
        self.s.append(nums[index])
        self.findSubsets(nums, index + 1)
        self.s.pop()

```


#### JavaScript代码模板

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    var ans = []
    var s = []
    var findSubsets = function(index) {
        if (index == nums.length) {
            ans.push(s.slice())
            return
        }
        findSubsets(index + 1)
        s.push(nums[index])
        findSubsets(index + 1)
        s.pop()
    }
    findSubsets(0)
    return ans
};
```
#### Golang代码模板

```go
func subsets(nums []int) [][]int {
    var s []int
    var ans [][]int
    var findSubsets func(index int)
    findSubsets = func(index int) {
        if index == len(nums) {
            ans = append(ans, make([]int, 0))
            for _, i := range s {
                ans[len(ans) - 1] = append(ans[len(ans) - 1], i)
            }
            return
        }
        findSubsets(index + 1)
        s = append(s, nums[index])
        findSubsets(index + 1)
        s = s[: len(s) - 1]
    }
    findSubsets(0)
    return ans
}
```





## 第 3 周

### [ BFS 拓扑排序模板](https://shimo.im/docs/XA5O1Uko38QamC75)
#### C/C++代码模板

```c++
//C/C++
// LeetCode210 课程表II

class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        n = numCourses;
        // 出边数组初始化，n个空list
        edges = vector<vector<int>>(n, vector<int>());
        inDeg = vector<int>(n, 0);
        for (vector<int>& pre : prerequisites) {
            int ai = pre[0];
            int bi = pre[1];
            // 加边模板
            addEdge(bi, ai);
        }
        auto ans = topsort();
        if (ans.size() < n) return {}; // 不能完成所有课程
        return ans;
    }

private:
    // 有向图找环 模板（拓扑排序）
    // 返回学的课程数
    vector<int> topsort() {
        vector<int> order;
        // 拓扑排序基于BFS，需要队列
        queue<int> q;
        // 从所有零入度点出发
        for (int i = 0; i < n; i++)
            if (inDeg[i] == 0) q.push(i);
        // 执行BFS
        while (!q.empty()) {
            int x = q.front(); // 取队头（这门课学了）
            q.pop();
            order.push_back(x);
            // 考虑x的所有出边
            for (int y : edges[x]) {
                inDeg[y]--; // 去掉约束关系
                if (inDeg[y] == 0) {
                    q.push(y);
                }
            }
        }
        return order;
    }

    void addEdge(int x, int y) {
        edges[x].push_back(y);
        inDeg[y]++;
    }

    int n;
    vector<vector<int>> edges;
    vector<int> inDeg; // in degree 入度
};
```

#### Java代码模板

```java
// Java
// LeetCode210 课程表II

class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 初始化
        n = numCourses;
        edges = new ArrayList<List<Integer>>();
        inDeg = new int[n];
        for (int i = 0; i < n; i++) {
           edges.add(new ArrayList<Integer>());
           inDeg[i] = 0;
        }
        // 建图，加边
        for (int[] pre : prerequisites) {
            int ai = pre[0];
            int bi = pre[1];
            addEdge(bi, ai);
        }
        // 拓扑排序
        return topsort();
    }

    int[] topsort() {
        int[] order = new int[n];
        int m = 0;
        Queue<Integer> q = new LinkedList<Integer>();
        // 零入度点入队
        for (int i = 0; i < n; i++)
            if (inDeg[i] == 0) q.offer(i);
        while (!q.isEmpty()) {
            Integer x = q.poll();
            order[m] = x;
            m++;
            // 扩展每个点
            for (Integer y : edges.get(x)) {
                inDeg[y]--;
                if (inDeg[y] == 0) q.offer(y);
            }
        }
        // n个课程都进出过队列，说明可以完成
        if (m == n) return order;
        return new int[0];
    }

    private void addEdge(int x, int y) {
        edges.get(x).add(y);
        inDeg[y]++;
    }

    private int n;
    private List<List<Integer>> edges;
    private int[] inDeg;
}
```

#### Python代码模板

```python
# Python
# LeetCode210 课程表II

from collections import deque

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # 初始化
        self.n = numCourses
        self.edge = [[] for i in range(numCourses)]
        self.inDeg = [0] * numCourses
        # 加边
        for pre in prerequisites:
            ai, bi = pre[0], pre[1]
            self.addEdge(bi, ai)
        return self.topsort()

    def topsort(self):
        order = []
        q = deque()
        for i in range(self.n):
            if self.inDeg[i] == 0:
                q.append(i)
        while len(q) > 0:
            x = q.popleft()
            order.append(x)
            for y in self.edge[x]:
                self.inDeg[y] -= 1
                if self.inDeg[y] == 0:
                    q.append(y)
        if len(order) == self.n:
            return order
        return []

    def addEdge(self, u, v):
        self.edge[u].append(v)
        self.inDeg[v] += 1
```

#### JavaScript代码模板

```javascript
// JavaScript
// LeetCode210 课程表II
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
    var edge = [];
    var inDeg = [];
    for (let i = 0; i < numCourses; i++) {
        edge[i] = [];
        inDeg[i] = 0;
    }

    var addEdge = function(x, y) {
        edge[x].push(y);
        inDeg[y]++;
    }

    var topsort = function() {
        var q = [];
        var order = [];
        for (let i = 0; i < numCourses; i++)
            if (inDeg[i] == 0) q.push(i);
        while (q.length > 0) {
            let x = q.shift();
            order.push(x);
            for (const y of edge[x]) {
                inDeg[y]--;
                if (inDeg[y] == 0) q.push(y);
            }
        }
        if (order.length == numCourses) return order;
        return [];
    }

    for (const pre of prerequisites) {
        addEdge(pre[1], pre[0]);
    }
    return topsort();
};
```
#### Golang代码模板

```go
//Go
// LeetCode210 课程表II

func topsort(outCome [][]int, inCome []int, numCourses int) {
	queue := make([]int,0)
	for i:=0; i<numCourses; i++ {
		if inCome[i] == 0 {
			queue = append(queue,i)
		}
	}
	rst := make([]int,0)
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		rst = append(rst,node)
		for _,v := range outCome[node] {
			inCome[v]--
			if inCome[v] == 0 {
				queue = append(queue,v)
			}
		}
	}
	// 如果没有环，则认为是true
	if len(rst) == numCourses {
		return rst
	}

    return nil
}

func findOrder(numCourses int, prerequisites [][]int) []int {
	outCome := make([][]int,numCourses)
	inCome := make([]int,numCourses)

	// 有向图由pre[i][1] -> pre[i][0]
	for i:=0; i<len(prerequisites); i++ {
		outCome[prerequisites[i][1]] = append(outCome[prerequisites[i][1]],prerequisites[i][0])
		inCome[prerequisites[i][0]]++
	}

	return topsort(outCome, inCome, numCourses)
}

```




### [ BFS 地图类模板](https://shimo.im/docs/gGV3vvckPQ3yD6jp)
#### C/C++代码模板

```c++
//C/C++

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        this->m = grid.size();
        this->n = grid[0].size();
        visit = vector<vector<bool>>(m, vector<bool>(n, false));
        int ans = 0;
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (grid[i][j] == '1' && !visit[i][j]) {
                    bfs(grid, i, j);
                    ans++;
                }
        return ans;
    }

private:
    // 从(sx,sy)出发bfs
    void bfs(vector<vector<char>>& grid, int sx, int sy) {
        // 长度为2的list或者pair都可以
        queue<pair<int,int>> q;
        // 第一步：push起点
        q.push(make_pair(sx,sy));
        visit[sx][sy] = true;
        while (!q.empty()) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            // 扩展所有出边（四个方向）
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                // 任何时候访问数组前，判断合法性
                if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;
                if (grid[nx][ny] == '1' && !visit[nx][ny]) {
                    q.push(make_pair(nx, ny));
                    // BFS：入队时标记visit
                    visit[nx][ny] = true;
                }
            }
        }
    }

    int m;
    int n;
    vector<vector<bool>> visit;
    const int dx[4] = {-1, 0, 0, 1};
    const int dy[4] = {0, -1, 1, 0};
};
```

#### Java代码模板

```java
//Java

class Solution {
    public int numIslands(char[][] grid) {
        m = grid.length;
        n = grid[0].length;
        visit = new boolean[m][n];
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                visit[i][j] = false;

        int ans = 0;
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (grid[i][j] == '1' && !visit[i][j]) {
                    bfs(grid, i, j);
                    ans++;
                }
        return ans;
    }

    // 从(sx,sy)出发bfs
    private void bfs(char[][] grid, int sx, int sy) {
        int[] dx = {-1, 0, 0, 1};
        int[] dy = {0, -1, 1, 0};
        Queue<Pair<Integer,Integer>> q = new LinkedList<Pair<Integer,Integer>>();
        // 第一步：push起点
        q.offer(new Pair<Integer,Integer>(sx,sy));
        visit[sx][sy] = true;
        while (!q.isEmpty()) {
            int x = q.peek().getKey();
            int y = q.poll().getValue();
            // 扩展所有出边（四个方向）
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                // 任何时候访问数组前，判断合法性
                if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;
                if (grid[nx][ny] == '1' && !visit[nx][ny]) {
                    q.offer(new Pair<Integer,Integer>(nx, ny));
                    // BFS：入队时标记visit
                    visit[nx][ny] = true;
                }
            }
        }
    }

    private int m;
    private int n;
    private boolean[][] visit;
};
```

#### Python代码模板

```python
# Python

from collections import deque 

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        self.m = len(grid)
        self.n = len(grid[0])
        self.visit = [[False] * self.n for i in range(self.m)]
        ans = 0
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j] == '1' and not self.visit[i][j]:
                    self.bfs(grid, i, j)
                    ans += 1
        return ans

    def bfs(self, grid, sx, sy):
        dx = [-1, 0, 0, 1]
        dy = [0, -1, 1, 0]
        q = deque()
        # 第一步：push起点
        q.append([sx, sy])
        self.visit[sx][sy] = True
        while len(q) > 0:
            now = q.popleft()
            x, y = now[0], now[1]
            # 扩展所有出边（四个方向）
            for i in range(4):
                nx = x + dx[i]
                ny = y + dy[i]
                # 任何时候访问数组前，判断合法性
                if nx < 0 or ny < 0 or nx >= self.m or ny >= self.n:
                    continue
                if grid[nx][ny] == '1' and not self.visit[nx][ny]:
                    q.append([nx, ny])
                    # BFS：入队时标记visit
                    self.visit[nx][ny] = True
```

#### JavaScript代码模板

```javascript
//JavaScript

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    const m = grid.length;
    const n = grid[0].length;
    var visit = [];
    for (let i = 0; i < m; i++) {
        visit.push([]);
        for (let j = 0; j < n; j++)
            visit[i][j] = false;
    }
    const dx = [-1, 0, 0, 1];
    const dy = [0, -1, 1, 0];

    var bfs = function(sx, sy) {
        var q = []
        // 第一步：push起点
        q.push([sx, sy]);
        visit[sx][sy] = true;
        while (q.length > 0) {
            var now = q.shift();
            var x = now[0];
            var y = now[1];
            // 扩展所有出边（四个方向）
            for (let i = 0; i < 4; i++) {
                let nx = x + dx[i];
                let ny = y + dy[i];
                // 任何时候访问数组前，判断合法性
                if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;
                if (grid[nx][ny] == '1' && !visit[nx][ny]) {
                    q.push([nx, ny]);
                    // BFS：入队时标记visit
                    visit[nx][ny] = true;
                }
            }
        }
    };

    var ans = 0;
    for (let i = 0; i < m; i++)
        for (let j = 0; j < n; j++)
            if (grid[i][j] == '1' && !visit[i][j]) {
                bfs(i, j);
                ans++;
            }
    return ans;
};
```

#### Golang代码模板

```go
//Golang

func numIslands(grid [][]byte) int {
    m := len(grid)
    n := len(grid[0])
    visit := make([][]bool, 0)
    for i := 0; i < m; i++ {
        visit = append(visit, make([]bool, n))
    }
    dx := []int{-1, 0, 0, 1}
    dy := []int{0, -1, 1, 0}
    var bfs func(int, int)
    
    bfs = func(sx int, sy int) {
        q := make([][]int, 0)
        // 第一步：push起点
        q = append(q, []int{sx, sy})
        for len(q) > 0 {
            now := q[0]
            q = q[1:]
            x, y := now[0], now[1]
            // 扩展所有出边（四个方向）
            for i := 0; i < 4; i++ {
                nx := x + dx[i]
                ny := y + dy[i]
                // 任何时候访问数组前，判断合法性
                if nx < 0 || ny < 0 || nx >= m || ny >= n {
                    continue
                }
                if grid[nx][ny] == '1' && !visit[nx][ny] {
                    q = append(q, []int{nx, ny})
                    // BFS：入队时标记visit
                    visit[nx][ny] = true
                }
            }
        }
    }
    
    ans := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
             if grid[i][j] == '1' && !visit[i][j] {
                bfs(i, j)
                ans++
            }
        }
    }
    
    return ans;
};
```


### [ DFS 无向图找环模板](https://shimo.im/docs/THukGd6uEqo8JPlb)
#### C/C++代码模板

```c++
//C/C++
// LeetCode684 冗余连接
// 本题有更高效解法，本解法主要练习DFS找环

class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        for (vector<int>& e : edges) {
            int u = e[0], v = e[1];
            n = max(n, u);
            n = max(n, v);
        }
        // 模板：出边数组初始化
        edge = vector<vector<int>>(n + 1, vector<int>());
        visit = vector<bool>(n + 1, false);
        hasCycle = false;
        for (vector<int>& e : edges) {
            int u = e[0], v = e[1];
            addEdge(u, v);
            addEdge(v, u);
            dfs(u, 0);
            if (hasCycle) return e;
        }
        return {};
    }

private:
    // 模板：DFS无向图找环
    void dfs(int x, int fa) {
        visit[x] = true;
        for (int y : edge[x]) {
            if (y == fa) continue;
            if (!visit[y]) dfs(y, x);
            else hasCycle = true;
        }
        visit[x] = false;
    }

    // 模板：加边
    void addEdge(int x, int y) {
        edge[x].push_back(y);
    }

    int n;
    vector<vector<int>> edge;
    vector<bool> visit;
    bool hasCycle;
};
```

#### Java代码模板

```java
// Java
// LeetCode684 冗余连接
// 本题有更高效解法，本解法主要练习DFS找环

class Solution {
    public int[] findRedundantConnection(int[][] input) {
        // 出现过的最大的点就是n
        n = 0;
        for (int[] edge : input) {
            int u = edge[0];
            int v = edge[1];
            n = Math.max(u, n);
            n = Math.max(v, n);
        }

        // 模板：出边数组初始化
        // 初态：[[], [], ... []]
        edges = new ArrayList<List<Integer>>();
        // [false, false, ...]
        visit = new boolean[n + 1];
        for (int i = 0; i <= n; i++) {
            edges.add(new ArrayList<Integer>());
            visit[i] = false;
        }
        hasCycle = false;

        // 加边
        for (int[] edge : input) {
            int u = edge[0];
            int v = edge[1];
            // 无向图看作双向边的有向图
            addEdge(u, v);
            addEdge(v, u);

            // 每加一条边，看图中是否多了环c
            for (int i = 0; i <= n; i++) visit[i] = false;
            dfs(u, -1);
            if (hasCycle) return edge;
        }
        return null;
    }

    // 模板：无向图深度优先遍历找环
    // visit数组，避免重复访问
    // fa是第一次走到x的点
    private void dfs(int x, int fa) {
        // 第一步：标记已访问
        visit[x] = true;
        // 第二步：遍历所有出边
        for (Integer y : edges.get(x)) {
            if (y == fa) continue; // 返回父亲，不是环
            if (visit[y]) hasCycle = true;
            else dfs(y, x);
        }
    }

    // 模板：加边
    private void addEdge(int x, int y) {
        edges.get(x).add(y);
    }

    // 出边数组
    int n;
    private List<List<Integer>> edges;
    boolean hasCycle;
    private boolean[] visit;
}
```

#### Python代码模板

```python
# Python
# LeetCode684 冗余连接
# 本题有更高效解法，本解法主要练习DFS找环

class Solution:
    def findRedundantConnection(self, input: List[List[int]]) -> List[int]:
        # 模板：出边数组初始化
        self.edge = [[] for i in range(1001)]  # max n is 1000
        self.hasCycle = False
        for e in input:
            u, v = e[0], e[1]
            self.addEdge(u, v)
            self.addEdge(v, u)
            self.visit = [False] * 1001
            self.dfs(u, -1)
            if self.hasCycle:
                return e
        return []

    # 模板：DFS无向图找环
    def dfs(self, x, fa):
        self.visit[x] = True
        for y in self.edge[x]:
            if y == fa:
                continue
            if self.visit[y]:
                self.hasCycle = True
            else:
                self.dfs(y, x)

    # 模板：加边
    def addEdge(self, u, v):
        self.edge[u].append(v)
```

#### JavaScript代码模板

```javascript
// JavaScript
// LeetCode684 冗余连接
// 本题有更高效解法，本解法主要练习DFS找环
/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantConnection = function(edges) {
    var n = 0
    for (let e of edges) {
        n = Math.max(n, e[0])
        n = Math.max(n, e[1])
    }
    // 模板：出边数组初始化
    var edge = [];
    for (let i = 0; i <= n; i++) edge[i] = [];
    var visit = [];
    var hasCycle = false;

    // 模板：加边
    var addEdge = function(u, v) {
        edge[u].push(v);
    }

    // 模板：DFS无向图找环
    var dfs = function(x, fa) {
        visit[x] = true;
        for (let y of edge[x]) {
            if (y == fa) continue;
            if (visit[y]) hasCycle = true;
            else dfs(y, x);
        }
    }

    for (let e of edges) {
        let u = e[0];
        let v = e[1];
        addEdge(u, v);
        addEdge(v, u);
        for (let i = 0; i <= n; i++) visit[i] = false;
        dfs(u, -1);
        if (hasCycle) return e;
    }
    return [];
};
```

#### Golang代码模板

```go
// Golang
// LeetCode684 冗余连接
// 本题有更高效解法，本解法主要练习DFS找环

func findRedundantConnection(edges [][]int) []int {
    n := 0
    for _, e  := range edges {
        if n < e[0] {
            n = e[0]
        }
        if n < e[1] {
            n = e[1]
        }
    }
    // 模板：出边数组初始化
    edge := make([][]int, n + 1)
    visit := make([]bool, n + 1)
    hasCycle := false

    // 模板：加边
    addEdge := func(u, v int) {
        edge[u] = append(edge[u], v)
    }

    // 模板：DFS无向图找环
    var dfs func(int, int)
    dfs = func(x, fa int) {
        visit[x] = true
        for _, y := range edge[x] {
            if y == fa {
                continue
            }
            if visit[y] {
                hasCycle = true
            } else {
                dfs(y, x)
            }
        }
    }

    for _, e := range edges {
        u, v := e[0], e[1]
        addEdge(u, v)
        addEdge(v, u)
        visit = make([]bool, n + 1)
        dfs(u, -1)
        if (hasCycle) {
            return e
        }
    }
    return nil
};
```




## 第 4 周

### [二叉堆代码模板](https://shimo.im/docs/KPT4pzQxZxQlsRS2)
#### Java代码模板

```java
// Java
// Leetcode23 合并K个升序链表

import java.util.Collections;

// 堆结点（key用于比较的关键码，listNode可以是任意的附带信息）
public class Node {
    int key;
    ListNode listNode;
    Node(int key, ListNode listNode) {
        this.key = key;
        this.listNode = listNode;
    }
}

// 小根二叉堆
class BinaryHeap {
    public BinaryHeap() {
        heap = new ArrayList<Node>();
    }

    public boolean isEmpty() {
        return heap.isEmpty();
    }

    public void push(Node node) {
        // 插入到尾部
        heap.add(node);
        // 向上调整
        heapifyUp(heap.size() - 1);
    }                

    public Node pop() {
        Node ans = heap.get(0);
        // 末尾交换到头部，然后删除末尾
        Collections.swap(heap, 0, heap.size() - 1);
        heap.remove(heap.size() - 1);
        // 向下调整
        heapifyDown(0);
        return ans;
    }

    void heapifyUp(int p) {        
        while (p > 0) {
            int fa = (p - 1) / 2;
            if (heap.get(p).key < heap.get(fa).key) { // 小根堆
                Collections.swap(heap, p, fa);
                p = fa;
            }
            else break;
        }
    }

    void heapifyDown(int p) {
        int child = p * 2 + 1;
        while (child < heap.size()) {  // child未出界，说明p有合法的child，还不是叶子
            int otherChild = p * 2 + 2;
            // 先比较两个孩子，谁小就继续跟p比较
            // child存较小的孩子
            if (otherChild < heap.size() && heap.get(child).key > heap.get(otherChild).key)
                child = otherChild;
            // 让child跟p比较
            if (heap.get(p).key > heap.get(child).key) { // 小根堆
                Collections.swap(heap, p, child);
                p = child;
                child = p * 2 + 1;
            }
            else break;
        }
    }

    // 数组存储完全二叉树
    // 从索引0开始存
    List<Node> heap;
};

class Solution {
    // O(元素个数*logK)
    // O(total*logK)
    public ListNode mergeKLists(ListNode[] lists) {
        BinaryHeap q = new BinaryHeap();
        for (ListNode listNode : lists) {
            if (listNode != null)
                q.push(new Node(listNode.val, listNode));
        }
        ListNode head = new ListNode();
        ListNode tail = head;
        while (!q.isEmpty()) {
            // 取出k个指针指向的最小元素
            Node node = q.pop();
            // 在答案链表的末尾插入
            tail.next = node.listNode;
            tail = tail.next;
            // 当最小被取出后，指针向后移动一位，可能需要插入新的元素
            ListNode p = node.listNode.next;
            if (p != null) {
                q.push(new Node(p.val, p));
            }
        }
        return head.next;
    }
};
```

#### C/C++代码模板

```c++
// C/C++
// Leetcode23 合并K个升序链表

// 堆结点（key用于比较的关键码，listNode可以是任意的附带信息）
struct Node {
    int key;
    ListNode* listNode;
    Node(int key, ListNode* listNode)  : key(key), listNode(listNode) {}
};

// 小根二叉堆
class BinaryHeap {
public:
    bool empty() {
        return heap.empty();
    }
    void push(const Node& node) {
        // 插入到尾部
        heap.push_back(node);
        // 向上调整
        heapifyUp(heap.size() - 1);
    }

    Node pop() {
        Node ans = heap[0];
        // 末尾交换到头部，然后删除末尾
        heap[0] = heap[heap.size() - 1];
        heap.pop_back();
        // 向下调整
        heapifyDown(0);
        return ans;
    }

private:
    void heapifyUp(int p) {
        while (p > 0) {
            int fa = (p - 1) / 2;
            if (heap[p].key < heap[fa].key) { // 小根堆
                swap(heap[p], heap[fa]);
                p = fa;
            }
            else break;
        }
    }

    void heapifyDown(int p) {
        int child = p * 2 + 1;
        while (child < heap.size()) {  // child未出界，说明p有合法的child，还不是叶子
            int otherChild = p * 2 + 2;
            // 先比较两个孩子，谁小就继续跟p比较
            // child存较小的孩子
            if (otherChild < heap.size() && heap[child].key > heap[otherChild].key)
                child = otherChild;
            // 让child跟p比较
            if (heap[p].key > heap[child].key) { // 小根堆
                swap(heap[p], heap[child]);
                p = child;
                child = p * 2 + 1;
            }
            else break;
        }
    }

    // 数组存储完全二叉树
    // 从索引0开始存
    vector<Node> heap;
};

class Solution {
public:
    // O(元素个数*logK)
    // O(total*logK)
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        BinaryHeap q;
        for (ListNode* listNode : lists) {
            if (listNode != nullptr)
                q.push(Node(listNode->val, listNode));
        }
        ListNode head;
        ListNode* tail = &head;
        while (!q.empty()) {
            // 取出k个指针指向的最小元素
            Node node = q.pop();
            // 在答案链表的末尾插入
            tail->next = node.listNode;
            tail = tail->next;
            // 当最小被取出后，指针向后移动一位，可能需要插入新的元素
            ListNode* p = node.listNode->next;
            if (p != nullptr) {
                q.push(Node(p->val, p));
            }
        }
        return head.next;
    }
};
```


#### JavaScript代码模板

```javascript
// JavaScript
// Leetcode23 合并K个升序链表

// 小根二叉堆
class BinaryHeap {
    constructor() {
        // 数组存储完全二叉树
        // 从索引0开始存
        this.heap = [];
    }

    swap(i, j) {
        let temp = this.heap[i];
        this.heap[i] = this.heap[j];
        this.heap[j] = temp;
    }

    isEmpty() {
        return this.heap.length == 0;
    }

    push(node) {
        // 插入到尾部
        this.heap.push(node);
        // 向上调整
        this.heapifyUp(this.heap.length - 1);
    }                

    pop() {
        let ans = this.heap[0];
        // 末尾交换到头部，然后删除末尾
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        // 向下调整
        this.heapifyDown(0);
        return ans;
    }

    heapifyUp(p) {        
        while (p > 0) {
            let fa = (p - 1) >> 1;  // 右移1位，等于整除2
            if (this.heap[p].key < this.heap[fa].key) { // 小根堆
                this.swap(p, fa);
                p = fa;
            }
            else break;
        }
    }

    heapifyDown(p) {
        let child = p * 2 + 1;
        while (child < this.heap.length) {  // child未出界，说明p有合法的child，还不是叶子
            let otherChild = p * 2 + 2;
            // 先比较两个孩子，谁小就继续跟p比较
            // child存较小的孩子
            if (otherChild < this.heap.length && this.heap[child].key > this.heap[otherChild].key)
                child = otherChild;
            // 让child跟p比较
            if (this.heap[p].key > this.heap[child].key) { // 小根堆
                this.swap(p, child);
                p = child;
                child = p * 2 + 1;
            }
            else break;
        }
    }
};

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    // O(元素个数*logK)
    // O(total*logK)
    let q = new BinaryHeap();
    for (let listNode of lists) {
        if (listNode != null)
            q.push({key: listNode.val, listNode: listNode});
    }
    let head = new ListNode();
    let tail = head;
    while (!q.isEmpty()) {
        // 取出k个指针指向的最小元素
        let node = q.pop();
        // 在答案链表的末尾插入
        tail.next = node.listNode;
        tail = tail.next;
        // 当最小被取出后，指针向后移动一位，可能需要插入新的元素
        let p = node.listNode.next;
        if (p != null) {
            q.push({key: p.val, listNode: p});
        }
    }
    return head.next;
};
```

#### Python代码模板

```python
# Python
# LeetCode23 合并K个升序链表

from collections import namedtuple

# 堆结点（key用于比较的关键码，listNode可以是任意的附带信息）
Node = namedtuple('Node', ['key', 'listNode'])

# 小根二叉堆
class BinaryHeap:
    def __init__(self):
        # 数组存储完全二叉树
        # 从索引0开始存
        self.heap = [];

    def empty(self):
        return len(self.heap) == 0

    def push(self, node):
        # 插入到尾部
        self.heap.append(node)
        # 向上调整
        self.heapifyUp(len(self.heap) - 1) 

    def pop(self):
        ans = self.heap[0]
        # 末尾交换到头部，然后删除末尾
        self.heap[0] = self.heap[-1]
        self.heap.pop()
        # 向下调整
        self.heapifyDown(0)
        return ans

    def heapifyUp(self, p):        
        while p > 0:
            fa = (p - 1) // 2
            if self.heap[p].key < self.heap[fa].key: # 小根堆
                self.heap[p], self.heap[fa] = self.heap[fa], self.heap[p]
                p = fa
            else:
                break

    def heapifyDown(self, p):
        child = p * 2 + 1
        while child < len(self.heap):  # child未出界，说明p有合法的child，还不是叶子
            otherChild = p * 2 + 2
            # 先比较两个孩子，谁小就继续跟p比较
            # child存较小的孩子
            if otherChild < len(self.heap) and self.heap[child].key > self.heap[otherChild].key:
                child = otherChild
            # 让child跟p比较
            if self.heap[p].key > self.heap[child].key:  # 小根堆
                self.heap[p], self.heap[child] = self.heap[child], self.heap[p]
                p = child
                child = p * 2 + 1
            else:
                break

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        # O(元素个数*logK)
        # O(total*logK)
        q = BinaryHeap()
        for listNode in lists:
            if listNode != None:
                q.push(Node(listNode.val, listNode))
        head = ListNode()
        tail = head
        while not q.empty():
            # 取出k个指针指向的最小元素
            node = q.pop()
            # 在答案链表的末尾插入
            tail.next = node.listNode
            tail = tail.next
            # 当最小被取出后，指针向后移动一位，可能需要插入新的元素
            p = node.listNode.next
            if p:
                q.push(Node(p.val, p))
        return head.next
```

#### Golang代码模板

```go
func mergeKLists(lists []*ListNode) *ListNode {
	k := len(lists)
	if k == 0 {
		return nil
	} else if k == 1 {
		return lists[0]
	} else {
		heap := NewMinHeap()
		var result *ListNode
		node := result
		for _, list := range lists {
			heap.Push(list)
		}
		for heap.length != 0 {
			tmp, err := heap.Pop()
			if err != nil {
				break
			}
			if node == nil {
				result = tmp
				node = tmp
			} else {
				node.Next = tmp
				node = node.Next
			}
			heap.Push(tmp.Next)
		}
		return result
	}
}

// 初始化小顶堆
type MinHeap struct {
	data   []*ListNode
	length int
}

func NewMinHeap() *MinHeap {
	return &MinHeap{data: []*ListNode{}, length: 0}
}

func (this *MinHeap) Pop() (*ListNode, error) {
	if this.length == 0 {
		return nil, errors.New("heap has no elements")
	} else if this.length == 1 {
		result := this.data[0]
		this.length--
		this.data = this.data[1:]
		return result, nil
	} else {
		result := this.data[0]
		this.data[0], this.data[this.length-1] = this.data[this.length-1], this.data[0]
		this.data = this.data[:this.length-1]
		this.length--
		this.data = minHeapifyFromUp(this.data, 0, this.length-1)
		return result, nil
	}
}

func (this *MinHeap) Push(num *ListNode) {
    if num == nil {
		return
	}
	this.data = append(this.data, num)
	this.length++
	this.data = minHeapifyFromDown(this.data, this.length-1, 0)
}

// 小顶堆自上向下堆化
func heapifyUp(nums []*ListNode, start, end int) []*ListNode {
	left := 2*start + 1
	for left <= end {
		tmp := left
		right := left + 1
		if right <= end && nums[right].Val < nums[tmp].Val {
			tmp = right
		}
		if nums[tmp].Val < nums[start].Val {
			nums[tmp], nums[start] = nums[start], nums[tmp]
			start = tmp
			left = start*2 + 1
		} else {
			break
		}
	}

	return nums
}

// 小顶堆自下向上堆化
func heapifyDown(nums []*ListNode, start, end int) []*ListNode {
	father := (start - 1) / 2
	for father >= end && father != start {
		if nums[start].Val < nums[father].Val {
			nums[father], nums[start] = nums[start], nums[father]
			start = father
			father = (start - 1) / 2
		} else {
			break
		}
	}

	return nums
}
```


### [二分查找代码模板](https://shimo.im/docs/p6mvnQXcgBUZteZx)
#### Python代码模板

```
# Python

# 普通二分查找
left, right = 0, len(array) - 1 
while left <= right: 
	  mid = (left + right) / 2 
	  if array[mid] == target: 
		    # find the target!! 
		    break or return result 
	  elif array[mid] < target: 
		    left = mid + 1 
	  else: 
		    right = mid - 1

# 更通用的二分模板
# LeetCode34 在排序数组中查找元素的第一个和最后一个位置
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        ans = [-1, -1]
        # 开始位置（lower_bound）：查询第一个>=target的数
        # 范围 [0 .. n-1 ] + [n表示不存在]
        left = 0
        right = len(nums)
        while left < right:
            mid = (left + right) >> 1
            if nums[mid] >= target:
                right = mid
            else:
                left = mid + 1
        ans[0] = right  #第一个>=target的数的下标（不存在为n）

        # 结束位置：查询最后一个<=target的数
        # 范围 [-1表示不存在] + [0 .. n-1 ]
        left = -1
        right = len(nums) - 1
        while left < right:
            mid = (left + right + 1) >> 1
            if nums[mid] <= target:
                left = mid
            else:
                right = mid - 1
        ans[1] = right #最后一个<=target的数（不存在为-1）

        # target出现在[ans[0], ans[1]]
        if ans[0] > ans[1]:
            ans = [-1, -1]
        return ans

# 实数二分模板
# ans = realSqrt(x, 1e-6)
# 如果要求4位小数，就多算2~4位，到1e-6或1e-8，保证精确
def realSqrt(x, eps=1e-6):
    left, right = 0, max(x, 1)
    while right - left > eps:
        mid = (left + right) / 2
        if mid * mid <= x:
            left = mid
        else:
            right = mid
    return right
```

#### C/C++代码模板

```c++
// C/C++

// 普通二分查找
int binarySearch(const vector<int>& nums, int target) {
	int left = 0, right = (int)nums.size()-1;
	
	while (left <= right) {
		int mid = left + (right - left)/ 2;
		if (nums[mid] == target) return mid;
		else if (nums[mid] < target) left = mid + 1;
		else right = mid - 1;
	}
	
	return -1;
}

// 更通用的二分模板
// LeetCode34 在排序数组中查找元素的第一个和最后一个位置
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> ans;
        // 开始位置（lower_bound）：查询第一个>=target的数
        // 范围 [0 .. n-1 ] + [n表示不存在]
        int left = 0, right = nums.size();
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] >= target) right = mid;
            else left = mid + 1;
        }
        ans.push_back(right);  //第一个>=target的数的下标（不存在为n）

        // 结束位置：查询最后一个<=target的数
        // 范围 [-1表示不存在] + [0 .. n-1 ]
        left = -1, right = nums.size() - 1;
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (nums[mid] <= target) left = mid;
            else right = mid - 1;
        }
        ans.push_back(right); //最后一个<=target的数（不存在为-1）

        // target出现在[ans[0], ans[1]]
        if (ans[0] > ans[1]) ans = {-1, -1};
        return ans;
    }
};

// 实数二分模板
// ans = realSqrt(x)
// 如果要求4位小数，就多算2~4位，到1e-6或1e-8，保证精确
double realSqrt(double x, double eps = 1e-6) {
    double left = 0, right = max(x, 1.0);
    while (right - left > eps) {
        double mid = (left + right) / 2;
        if (mid * mid <= x) {
            left = mid;
        } else {
            right = mid;
        }
    }
    return right;
}
```

#### Java代码模板

```java
// Java

// 普通二分查找
public int binarySearch(int[] array, int target) {
    int left = 0, right = array.length - 1, mid;
    while (left <= right) {
        mid = (right - left) / 2 + left;

        if (array[mid] == target) {
            return mid;
        } else if (array[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return -1;
}

// 更通用的二分模板
// LeetCode34 在排序数组中查找元素的第一个和最后一个位置
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] ans = new int[2];
        // 开始位置（lower_bound）：查询第一个>=target的数
        // 范围 [0 .. n-1 ] + [n表示不存在]
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] >= target) right = mid;
            else left = mid + 1;
        }
        ans[0] = right;  //第一个>=target的数的下标（不存在为n）

        // 结束位置：查询最后一个<=target的数
        // 范围 [-1表示不存在] + [0 .. n-1 ]
        left = -1; right = nums.length - 1;
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (nums[mid] <= target) left = mid;
            else right = mid - 1;
        }
        ans[1] = right; //最后一个<=target的数（不存在为-1）

        // target出现在[ans[0], ans[1]]
        if (ans[0] > ans[1]) ans = new int[]{-1, -1};
        return ans;
    }
}

// 实数二分模板
// ans = realSqrt(x, 1e-6)
// 如果要求4位小数，就多算2~4位，到1e-6或1e-8，保证精确
double realSqrt(double x, double eps) {
    double left = 0, right = Math.max(x, 1);
    while (right - left > eps) {
        double mid = (left + right) / 2;
        if (mid * mid <= x) {
            left = mid;
        } else {
            right = mid;
        }
    }
}
```

#### JavaScript代码模板

```javascript
/* JavaScript */

// 普通二分查找
let left = 0, right = len(array) - 1
while (left <= right) {
  let mid = (left + right) >> 1
  if (array[mid] === target) { /*find the target*/; return }
  else if (array[mid] < target) left = mid + 1
  else right = mid - 1
}

// 更通用的二分模板
// LeetCode34 在排序数组中查找元素的第一个和最后一个位置
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
    let ans = [];
    // 开始位置（lower_bound）：查询第一个>=target的数
    // 范围 [0 .. n-1 ] + [n表示不存在]
    let left = 0, right = nums.length;
    while (left < right) {
        let mid = (left + right) >> 1;
        if (nums[mid] >= target) right = mid;
        else left = mid + 1;
    }
    ans[0] = right;  //第一个>=target的数的下标（不存在为n）

    // 结束位置：查询最后一个<=target的数
    // 范围 [-1表示不存在] + [0 .. n-1 ]
    left = -1; right = nums.length - 1;
    while (left < right) {
        let mid = (left + right + 1) >> 1;
        if (nums[mid] <= target) left = mid;
        else right = mid - 1;
    }
    ans[1] = right; //最后一个<=target的数（不存在为-1）

    // target出现在[ans[0], ans[1]]
    if (ans[0] > ans[1]) ans = [-1, -1];
    return ans;
};

// 实数二分模板
// ans = realSqrt(x, 1e-6)
// 如果要求4位小数，就多算2~4位，到1e-6或1e-8，保证精确
var realSqrt = function(x, eps=1e-6) {
    let left = 0, right = Math.max(x, 1);
    while (right - left > eps) {
        let mid = (left + right) / 2;
        if (mid * mid <= x) {
            left = mid;
        } else {
            right = mid;
        }
    }
    return right;
}
```

#### Golang代码模板

```go
// 普通二分查找
func binarySearch(nums []int, target int) int {
    var i, j = 0, len(nums) - 1
    for i <= j {
        var mid = i + (j - i) / 2
        if nums[mid] == target {
            return mid
        }
        if target > nums[mid] {
            i = mid + 1
        } else {
            j = mid - 1
        }
    }    
    return -1
}

// 更通用的二分模板
func searchRange(nums []int, target int) []int {
    left, right := 0, len(nums)-1
    for {
        if left > right {
            return []int{-1, -1}
        }
        mid := (left+right)/2
        if nums[mid] == target {
            leftBound := findLeftBound(nums, left, mid, target)
            rightBound := findRightBound(nums, mid, right, target)
            return []int{leftBound, rightBound}
        } else if nums[mid] > target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
}

func findLeftBound(nums []int, left, right, target int) int {
    for {
        if left > right {
            return left
        }
        mid := (left+right)/2
        if nums[mid] == target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
}

func findRightBound(nums []int, left, right, target int) int {
    for {
        if left > right {
            return right
        }
        mid := (left+right)/2
        if nums[mid] == target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
}

func realSqrt(x int, eps float64) float64 {
    left := 0.0
    right := x
    for (right - left > eps) {
        var mid = (left + right) / 2
        if mid * mid <= x {
            left = mid
        } else {
            right = mid
        }
    }
    return right
}
```



### [二叉搜索树代码模板](https://shimo.im/docs/JaQcdzApJQ8qVmoQ)
#### Java代码模板

```java
// Java

// 插入，保证val不存在
// 返回插入以后的新树根
TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }
    if (val < root.val) {
        root.left = insertIntoBST(root.left, val);
    } else {
        root.right = insertIntoBST(root.right, val);
    }
    return root;
}

// 求val的后继
TreeNode findSucc(TreeNode root, int val) {
    TreeNode curr = root;
    TreeNode ans = null;
    while (curr != null) {
        if (curr.val > val) { // case2：当后继存在于经过的点中（找到一个>val的最小点）
            // 含义：ans=min(ans, curr.val);
            if (ans == null || ans.val > curr.val)
                ans = curr;
        }
        if (curr.val == val) {
            if (curr.right != null) { // case1：检索到val且右子树存在，右子树一路向左
                curr = curr.right;
                while (curr.left != null) curr = curr.left;
                return curr;
            }
            break;
        }
        if (val < curr.val) curr = curr.left;
        else curr = curr.right;
    }
    return ans;
}

// 在以root为根的子树中删除key，返回新的根
TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null;
    if (root.val == key) {
        if (root.left == null) return root.right; // 没有左子树，让right代替root的位置
        if (root.right == null) return root.left; // 没有右子树
        TreeNode next = root.right;
        while (next.left != null) next = next.left; // 找后继：右子树一路向左
        root.right = deleteNode(root.right, next.val);
        root.val = next.val;
        return root;
    }
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else {
        root.right = deleteNode(root.right, key);
    }
    return root;
}
```

#### C/C++代码模板

```c++
// C/C++

// 插入，保证val不存在
// 返回插入以后的新树根
TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (root == nullptr) {
        return new TreeNode(val);
    }
    if (val < root->val) {
        root->left = insertIntoBST(root->left, val);
    } else {
        root->right = insertIntoBST(root->right, val);
    }
    return root;
}

// 求val的后继
TreeNode* findSucc(TreeNode* root, int val) {
    TreeNode* ans = nullptr;
    while (root != nullptr) {
        if (val == root->val) {
            if (root->right != nullptr) {
                TreeNode* p = root->right;
                while (p->left != nullptr) p = p->left;
                return p;
            }
            break;
        }
        if (root->val > val && (ans == nullptr || ans->val > root->val))
            ans = root;
        if (val < root->val) root = root->left; else root = root->right;            
    }
    return ans;
}

// 在以root为根的子树中删除key，返回新的根
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr) return nullptr;
    if (root->val == key) {
        if (root->left == nullptr) return root->right; // 没有左子树，让right代替root的位置
        if (root->right == nullptr) return root->left; // 没有右子树
        TreeNode* next = root->right;
        while (next->left != nullptr) next = next->left; // 找后继：右子树一路向左
        root->right = deleteNode(root->right, next->val);
        root->val = next->val;
        return root;
    }
    if (key < root->val) {
        root->left = deleteNode(root->left, key);
    } else {
        root->right = deleteNode(root->right, key);
    }
    return root;
}
```


#### JavaScript代码模板

```javascript
// JavaScript

// 插入，保证val不存在
// 返回插入以后的新树根
var insertIntoBST = function(root, val) {
    if (root == null) return new TreeNode(val);
    if (val < root.val)
        root.left = insertIntoBST(root.left, val);
    else
        root.right = insertIntoBST(root.right, val);
    return root;
};

// 求val的后继
var findSucc = function(root, val) {
    let ans = null;
    while (root != null) {
        if (val == root.val) {
            if (root.right != null) {
                let p = root.right;
                while (p.left != null) p = p.left;
                return p;
            }
            break;
        }
        if (root.val > val && (ans == null || ans.val > root.val))
            ans = root;
        if (val < root.val) root = root.left; else root = root.right;            
    }
    return ans;
}

// 在以root为根的子树中删除key，返回新的根
var deleteNode = function(root, key) {
    if (root == null) return null;
    if (root.val == key) {
        if (root.left == null) return root.right; // 没有左子树，让right代替root的位置
        if (root.right == null) return root.left; // 没有右子树
        let next = root.right;
        while (next.left != null) next = next.left; // 找后继：右子树一路向左
        root.right = deleteNode(root.right, next.val);
        root.val = next.val;
        return root;
    }
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else {
        root.right = deleteNode(root.right, key);
    }
    return root;
};
```

#### Python代码模板

```python
# Python

# 插入，保证val不存在
# 返回插入以后的新树
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if root is None:
            return TreeNode(val)
        if val < root.val:
            root.left = self.insertIntoBST(root.left, val)
        else:
            root.right = self.insertIntoBST(root.right, val)
        return root

# 求val的后继
    def findSucc(self, root, val):
        ans = None
        while root:
            if val == root.val:
                if root.right:
                    p = root.right
                    while p.left:
                        p = p.left
                    return p
                break
            if root.val > val:
                if ans is None or ans.val > root.val:
                    ans = root
            if val < root.val:
                root = root.left
            else:
                root = root.right
        return ans

# 在以root为根的子树中删除key，返回新的根
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if root is None:
            return None
        if root.val == key:
            # 没有左子树，让right代替root的位置
            if root.left is None:
                return root.right
            # 没有右子树
            if root.right is None:
                return root.left
            # 找后继：右子树一路向左
            next = root.right
            while next.left:
                next = next.left
            root.right = self.deleteNode(root.right, next.val)
            root.val = next.val
            return root
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        else:
            root.right = self.deleteNode(root.right, key)
        return root
```

#### Golang代码模板

```go
// Golang

// 插入，保证val不存在
// 返回插入以后的新树根
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return &TreeNode{Val: val}
    }
    if val < root.Val {
        root.Left = insertIntoBST(root.Left, val)
    } else {
        root.Right = insertIntoBST(root.Right, val)
    }
    return root;
}

// 求val的后继
func findSucc(root *TreeNode, val int) *TreeNode {
    var ans *TreeNode
    for root != nil {
        if val == root.Val {
            if root.Right != nil {
                p := root.Right
                for p.Left != nil {
                    p = p.Left
                } 
                return p
            }
            break
        }
        if root.Val > val && (ans == nil || ans.Val > root.Val) {
            ans = root
        }
        if val < root.Val {
            root = root.Left
        } else {
            root = root.Right
        }            
    }
    return ans
}

// 在以root为根的子树中删除key，返回新的根
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil {
        return nil
    }
    if root.Val == key {
        if root.Left == nil {
            return root.Right // 没有左子树，让right代替root的位置
        } 
        if root.Right == nil {
            return root.Left // 没有右子树
        } 
        next := root.Right
        for next.Left != nil {
            next = next.Left // 找后继：右子树一路向左
        }
        root.Right = deleteNode(root.Right, next.Val)
        root.Val = next.Val
        return root
    }
    if key < root.Val {
        root.Left = deleteNode(root.Left, key)
    } else {
        root.Right = deleteNode(root.Right, key)
    }
    return root
}
```



### [二叉搜索树插入模板](https://shimo.im/docs/JcGyKCx9VdkD9H8y)
#### Python代码模板

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if root is None:
            return TreeNode(val)
        if val < root.val:
            root.left = self.insertIntoBST(root.left, val)
        else:
            root.right = self.insertIntoBST(root.right, val)
        return root
```

#### C/C++代码模板

```c++
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 返回插入以后的新树根
    // （如果root本来就存在，还是返回root；如果root是空，返回新建的点）
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        if (val < root.val) {
            root.left = insertIntoBST(root.left, val);
        } else {
            root.right = insertIntoBST(root.right, val);
        }
        return root;
    }
}
```

#### Java代码模板

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 返回插入以后的新树根
    // （如果root本来就存在，还是返回root；如果root是空，返回新建的点）
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        if (val < root.val) {
            root.left = insertIntoBST(root.left, val);
        } else {
            root.right = insertIntoBST(root.right, val);
        }
        return root;
    }
}
```

#### JavaScript代码模板

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var insertIntoBST = function(root, val) {
    if (root == null) return new TreeNode(val);
    if (val < root.val)
        root.left = insertIntoBST(root.left, val);
    else
        root.right = insertIntoBST(root.right, val);
    return root;
};
```


#### Golang代码模板

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return &TreeNode{Val: val}
    }
    if val < root.Val {
        root.Left = insertIntoBST(root.Left, val)
    } else {
        root.Right = insertIntoBST(root.Right, val)
    }
    return root;
}
```


### [二叉搜索树删除模板](https://shimo.im/docs/XdPGrCrGjHXWPkDG)
#### Python代码模板

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    # 在以root为根的子树中删除key，返回新的根
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if root is None:
            return None
        if root.val == key:
            # 没有左子树，让right代替root的位置
            if root.left is None:
                return root.right
            # 没有右子树
            if root.right is None:
                return root.left
            # 找后继：右子树一路向左
            next = root.right
            while next.left:
                next = next.left
            root.right = self.deleteNode(root.right, next.val)
            root.val = next.val
            return root
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        else:
            root.right = self.deleteNode(root.right, key)
        return root
```

#### JavaScript代码模板

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
// 在以root为根的子树中删除key，返回新的根
var deleteNode = function(root, key) {
    if (root == null) return null;
    if (root.val == key) {
        if (root.left == null) return root.right; // 没有左子树，让right代替root的位置
        if (root.right == null) return root.left; // 没有右子树
        let next = root.right;
        while (next.left != null) next = next.left; // 找后继：右子树一路向左
        root.right = deleteNode(root.right, next.val);
        root.val = next.val;
        return root;
    }
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else {
        root.right = deleteNode(root.right, key);
    }
    return root;
};
```

#### Java代码模板

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 在以root为根的子树中删除key，返回新的根
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        if (root.val == key) {
            if (root.left == null) return root.right; // 没有左子树，让right代替root的位置
            if (root.right == null) return root.left; // 没有右子树
            TreeNode next = root.right;
            while (next.left != null) next = next.left; // 找后继：右子树一路向左
            root.right = deleteNode(root.right, next.val);
            root.val = next.val;
            return root;
        }
        if (key < root.val) {
            root.left = deleteNode(root.left, key);
        } else {
            root.right = deleteNode(root.right, key);
        }
        return root;
    }
}
```

#### C/C++代码模板

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 在以root为根的子树中删除key，返回新的根
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return nullptr;
        if (root->val == key) {
            if (root->left == nullptr) return root->right; // 没有左子树，让right代替root的位置
            if (root->right == nullptr) return root->left; // 没有右子树
            TreeNode* next = root->right;
            while (next->left != nullptr) next = next->left; // 找后继：右子树一路向左
            root->right = deleteNode(root->right, next->val);
            root->val = next->val;
            return root;
        }
        if (key < root->val) {
            root->left = deleteNode(root->left, key);
        } else {
            root->right = deleteNode(root->right, key);
        }
        return root;
    }
};
```
#### Golang代码模板

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func deleteNode(root *TreeNode, low int, high int) *TreeNode {
  if root == nil { return nil }
  if root.val == key {
    if root.left == nil { return root.right }
    if root.right == nil { return root.left }
    TreeNode* next = root.right
    for next.left != nil { next = next.left }
    root.right = deleteNode(root.right, next.val)
    root.val = next.val
    return root
  }
  if key < root.val {
    root.left = deleteNode(root.left, key);
  } else {
    root.right = deleteNode(root.right, key);
  }
  return root;
}
```

### [二叉搜索树后继模板](https://shimo.im/docs/9WCC6gRCDtpGPqh9)
####  Python代码模板

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> TreeNode:
        return self.findSucc(root, p.val)

    def findSucc(self, root, val):
        ans = None
        while root:
            if val == root.val:
                if root.right:
                    p = root.right
                    while p.left:
                        p = p.left
                    return p
                break
            if root.val > val:
                if ans is None or ans.val > root.val:
                    ans = root
            if val < root.val:
                root = root.left
            else:
                root = root.right
        return ans
```

#### JavaScript代码模板

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @return {TreeNode}
 */
var inorderSuccessor = function(root, p) {
    var findSucc = function(root, val) {
        let ans = null;
        while (root != null) {
            if (val == root.val) {
                if (root.right != null) {
                    let p = root.right;
                    while (p.left != null) p = p.left;
                    return p;
                }
                break;
            }
            if (root.val > val && (ans == null || ans.val > root.val))
                ans = root;
            if (val < root.val) root = root.left; else root = root.right;            
        }
        return ans;
    }

    return findSucc(root, p.val);
};
```

#### Java代码模板

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        return findSucc(root, p.val);
    }

    private TreeNode findSucc(TreeNode root, int val) {
        TreeNode curr = root;
        TreeNode ans = null;
        while (curr != null) {
            if (curr.val > val) { // case2：当后继存在于经过的点中（找到一个>val的最小点）
                // 含义：ans=min(ans, curr.val);
                if (ans == null || ans.val > curr.val)
                    ans = curr;
            }
            if (curr.val == val) {
                if (curr.right != null) { // case1：检索到val且右子树存在，右子树一路向左
                    curr = curr.right;
                    while (curr.left != null) curr = curr.left;
                    return curr;
                }
                break;
            }
            if (val < curr.val) curr = curr.left;
            else curr = curr.right;
        }
        return ans;
    }

}
```

#### C/C++代码模板

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        return find(root, p->val);
    }

    TreeNode* find(TreeNode* root, int val) {
        TreeNode* ans = nullptr;
        while (root != nullptr) {
            if (val == root->val) {
                if (root->right != nullptr) {
                    TreeNode* p = root->right;
                    while (p->left != nullptr) p = p->left;
                    return p;
                }
                break;
            }
            if (root->val > val && (ans == nullptr || ans->val > root->val))
                ans = root;
            if (val < root->val) root = root->left; else root = root->right;            
        }
        return ans;
    }
};
```


#### Golang代码模板

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode {
    return findSucc(root, p.Val)
}

func findSucc(root *TreeNode, val int) *TreeNode {
    var ans *TreeNode
    for root != nil {
        if val == root.Val {
            if root.Right != nil {
                p := root.Right
                for p.Left != nil {
                    p = p.Left
                } 
                return p
            }
            break
        }
        if root.Val > val && (ans == nil || ans.Val > root.Val) {
            ans = root
        }
        if val < root.Val {
            root = root.Left
        } else {
            root = root.Right
        }            
    }
    return ans
}
```




## 第 5 周

### [堆排序代码示例](https://shimo.im/docs/LneufQhYZB831RUl)

#### Java代码模板

```
// Java

static void heapify(int[] array, int length, int i) {
    int left = 2 * i + 1, right = 2 * i + 2；
    int largest = i;

    if (left < length && array[left] > array[largest]) {
        largest = left;
    }
    if (right < length && array[right] > array[largest]) {
        largest = right;
    }

    if (largest != i) {
        int temp = array[i]; array[i] = array[largest]; array[largest] = temp;
        heapify(array, length, largest);
    }
}

public static void heapSort(int[] array) {
    if (array.length == 0) return;

    int length = array.length;
    for (int i = length / 2-1; i >= 0; i-) 
        heapify(array, length, i);

    for (int i = length - 1; i >= 0; i--) {
        int temp = array[0]; array[0] = array[i]; array[i] = temp;
        heapify(array, i, 0);
    }
}
```

#### Python代码模板

```python
#Python

def heapify(parent_index, length, nums):
    temp = nums[parent_index]
    child_index = 2*parent_index+1
    while child_index < length:
        if child_index+1 < length and nums[child_index+1] > nums[child_index]:
            child_index = child_index+1
        if temp > nums[child_index]:
            break
        nums[parent_index] = nums[child_index]
        parent_index = child_index
        child_index = 2*parent_index + 1
    nums[parent_index] = temp



def heapsort(nums):
    for i in range((len(nums)-2)//2, -1, -1):
        heapify(i, len(nums), nums)
    for j in range(len(nums)-1, 0, -1):
        nums[j], nums[0] = nums[0], nums[j]
        heapify(0, j, nums)
```

#### C/C++代码模板

```c++
C/C++

void heapify(vector<int> &array, int length, int i) {
    int left = 2 * i + 1, right = 2 * i + 2;
    int largest = i;

    if (left < length && array[left] > array[largest]) {
        largest = left;
    }
    if (right < length && array[right] > array[largest]) {
        largest = right;
    }

    if (largest != i) {
        int temp = array[i]; array[i] = array[largest]; array[largest] = temp;
        heapify(array, length, largest);
    }



    return ;
}

void heapSort(vector<int> &array) {
    if (array.size() == 0) return ;

    int length = array.size();
    for (int i = length / 2 - 1; i >= 0; i--) 
        heapify(array, length, i);

    for (int i = length - 1; i >= 0; i--) {
        int temp = array[0]; array[0] = array[i]; array[i] = temp;
        heapify(array, i, 0);
    }

    return ;
}
```

#### JavaScript代码模板

```plain
// Javascript
function heapSort(arr) {
  if (arr.length === 0) return;
  let len = arr.length;

  // 建堆
  for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
    heapify(arr, len, i);
  }

  // 排序
  for (let i = len - 1; i >= 0; i--) {
    // 堆顶元素与最后一个互换
    [arr[0], arr[i]] = [arr[i], arr[0]];
    // 对 0 ～ i 的数组建堆
    heapify(arr, i, 0);
  }
}

function heapify(arr, len, i) {
  let left = i * 2 + 1;
  let right = i * 2 + 2;
  let largest = i;

  if (left < len && arr[left] > arr[largest]) {
    largest = left;
  }

  if (right < len && arr[right] > arr[largest]) {
    largest = right;
  }

  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, len, largest);
  }
}
```

#### Golang代码模板

```go
// Golang

func heapify(array []int, length, i int) {
    left, right := 2 * i + 1, 2 * i + 2
    largest := i

    if left < length && array[left] > array[largest] {
        largest = left
    }
    if right < length && array[right] > array[largest] {
        largest = right
    }

    if largest != i {
        array[i], array[largest] = array[largest], array[i]
        heapify(array, length, largest)
    }
}

func heapSort(array []int) {
    if len(array) == 0 {
        return
    }

    length := len(array)
    for i := length / 2-1; i >= 0; i-- {
        heapify(array, length, i)
    }

    for i := length - 1; i >= 0; i-- {
        array[0], array[i] = array[i], array[0]
    }
}
```



### [归并排序代码模板](https://shimo.im/docs/aHIgEa1aL2oJKxXb)
#### Java代码模板

```java
// Java

public static void mergeSort(int[] array, int left, int right) {
    if (right <= left) return;
    int mid = (left + right) >> 1; // (left + right) / 2

    mergeSort(array, left, mid);
    mergeSort(array, mid + 1, right);
    merge(array, left, mid, right);
}

public static void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1]; // 中间数组
        int i = left, j = mid + 1, k = 0;

        while (i <= mid && j <= right) {
            temp[k++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
        }

        while (i <= mid)   temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];

        for (int p = 0; p < temp.length; p++) {
            arr[left + p] = temp[p];
        }
        // 也可以用 System.arraycopy(a, start1, b, start2, length)
    }
```

#### C/C++代码模板

```c++
C/C++

void mergeSort(vector<int> &nums, int left, int right) {
	if (left >= right) return;
	
	int mid = left + (right - left) / 2;
	mergeSort(nums, left, mid);
	mergeSort(nums, mid+1, right);
	
	merge(nums, left, mid, right);
}



void merge(vector<int> &nums, int left, int mid, int right) {
	vector<int> tmp(right-left+1);
	int i = left, j = mid+1, k = 0;
	
	while (i <= mid && j <= right) {
		tmp[k++] = nums[i] < nums[j] ? nums[i++] : nums[j++];
	}
	while (i <= mid) tmp[k++] = nums[i++];
	while (j <= right) tmp[k++] = nums[j++];
	
	for (i = left, k = 0; i <= right;) nums[i++] = tmp[k++];
}

```



#### Python代码模板

```python
#Python

def mergesort(nums, left, right):
    if right <= left:
        return
    mid = (left+right) >> 1
    mergesort(nums, left, mid)
    mergesort(nums, mid+1, right)
    merge(nums, left, mid, right)

def merge(nums, left, mid, right):
    temp = []
    i = left
    j = mid+1
    while i <= mid and j <= right:
        if nums[i] <= nums[j]:
            temp.append(nums[i])
            i +=1
        else:
            temp.append(nums[j])
            j +=1
    while i<=mid:
        temp.append(nums[i])
        i +=1
    while j<=right:
        temp.append(nums[j])
        j +=1
    nums[left:right+1] = temp
```


#### JavaScript代码模板

```javascript
// JavaScript
const mergeSort = (nums) => {
  if (nums.length <= 1) return nums
  let mid = Math.floor(nums.length/2), 
      left = nums.slice(0, mid), 
      right = nums.slice(mid)
  return merge(mergeSort(left), mergeSort(right))
}

const merge = (left, right) => {
  let result = []
  while(left.length && right.length) {
    result.push(left[0] <= right[0] ? left.shift() : right.shift())
  }
  while(left.length) result.push(left.shift())
  while(right.length) result.push(right.shift())
  return result
}
```

#### Golang代码模板

```go
// Golang

func mergeSort(array []int, left, right int) {
    if right <= left {
        return
    }
    mid := (left + right) >> 1

    mergeSort(array, left, mid)
    mergeSort(array, mid + 1, right)
    merge(array, left, mid, right)
}

func merge(arr []int, left, mid, right int) {
    temp := make([]int, right - left + 1)
    i, j, k := left, mid + 1, 0

    for ;i <= mid && j <= right; k++ {
        if arr[i] <= arr[j] {
            temp[k] = arr[i]
            i++
        } else {
            temp[k] = arr[j]
            j++
        }
    }

    for ;i <= mid; k++ {
        temp[k] = arr[i]
        i++
    } 
    for ;j <= right; k++ {
        temp[k] = arr[j]
        j++
    }

    for i := range temp {
        arr[left + i] = temp[i]
    }
}
```


### [快速排序代码模板](https://shimo.im/docs/ACAlmaE7awcywe0P/read)
#### Java代码模板

```java
// Java

class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    public static void quickSort(int[] arr, int l, int r) {
        if (l >= r) return;
        int pivot = partition(arr, l, r);
        quickSort(arr, l, pivot);
        quickSort(arr, pivot + 1, r);
    }

    static int partition(int[] a, int l, int r) {
        int pivot = l + (int)(Math.random() * (r - l + 1));
        int pivotVal = a[pivot];

        while (l <= r) {
            while (a[l] < pivotVal) l++;
            while (a[r] > pivotVal) r--;
            if (l == r) break;
            if (l < r) {
                int temp = a[l]; a[l] = a[r]; a[r] = temp;
                l++; r--;
            }
        }

        return r;
    }
}
```

#### C/C++代码模板

```c++
// C/C++

class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, nums.size() - 1);
        return nums;
    }

    void quickSort(vector<int>& arr, int l, int r) {
        if (l >= r) return;
        int pivot = partition(arr, l, r);
        quickSort(arr, l, pivot);
        quickSort(arr, pivot + 1, r);
    }

    int partition(vector<int>& a, int l, int r) {
        int pivot = l + rand() % (r - l + 1);
        int pivotVal = a[pivot];

        while (l <= r) {
            while (a[l] < pivotVal) l++;
            while (a[r] > pivotVal) r--;
            if (l == r) break;
            if (l < r) {
                int temp = a[l]; a[l] = a[r]; a[r] = temp;
                l++; r--;
            }
        }

        return r;
    }
};
```


#### Python代码模板

```python
#Python

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.quickSort(nums, 0, len(nums) - 1)
        return nums

    def quickSort(self, arr, l, r):
        if l >= r:
            return
        pivot = self.partition(arr, l, r)
        self.quickSort(arr, l, pivot)
        self.quickSort(arr, pivot + 1, r)

    def partition(self, a, l, r):
        pivot = random.randint(l, r)
        pivotVal = a[pivot]

        while l <= r:
            while a[l] < pivotVal:
                l += 1
            while a[r] > pivotVal:
                r -= 1
            if l == r:
                break
            if l < r:
                a[l], a[r] = a[r], a[l]
                l += 1
                r -= 1

        return r
```


#### JavaScript代码模板

```javascript
// JavaScript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    quickSort(nums, 0, nums.length - 1);
    return nums;
}

var quickSort = function(arr, l, r) {
    if (l >= r) return;
    let pivot = partition(arr, l, r);
    quickSort(arr, l, pivot);
    quickSort(arr, pivot + 1, r);
}

var partition = function(a, l, r) {
    let pivot = l + Math.floor(Math.random() * (r - l + 1));
    let pivotVal = a[pivot];

    while (l <= r) {
        while (a[l] < pivotVal) l++;
        while (a[r] > pivotVal) r--;
        if (l == r) break;
        if (l < r) {
            let temp = a[l]; a[l] = a[r]; a[r] = temp;
            l++; r--;
        }
    }
    return r;
}
```

#### Golang代码模板

```go
// Golang

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    return nil
}

func sortArray (nums []int) []int {
    quickSort(nums, 0, len(nums) - 1)
    return nums
}

func quickSort(arr []int, l, r int) {
    if (l >= r) {
        return
    }
    pivot := partition(arr, l, r)
    quickSort(arr, l, pivot)
    quickSort(arr, pivot + 1, r)
}

func partition(a []int, l, r int) int {
    pivot := l + rand.Intn(r - l + 1)
    pivotVal := a[pivot]

    for l <= r {
        for a[l] < pivotVal {
            l++
        }
        for (a[r] > pivotVal) {
            r--
        }
        if (l == r) {
            break
        }
        if (l < r) {
            a[l], a[r] = a[r], a[l]
            l++
            r--
        }
    }
    return r
}
```




## 第 7 周

### [ Trie 树代码模板](https://shimo.im/docs/nD1XKe23RoQFSoD4)
#### Python代码模板

```
# Python 
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = [0, {}]  # [count, child]

    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        self.find(word, True, True)

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        return self.find(word, True, False)

    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        return self.find(prefix, False, False)
    
    def find(self, s, exact_match, insert_if_not_exist):
        curr = self.root
        for ch in s:
            if ch not in curr[1]:
                if not insert_if_not_exist:
                    return False
                curr[1][ch] = [0, {}]
            curr = curr[1][ch]
        if insert_if_not_exist:
            curr[0] += 1
        return curr[0] > 0 if exact_match else True

```
#### C/C++代码模板

```c++
//C/C++
class Trie {
public:
    /** Initialize your data structure here. */
    Trie() { 
        root = new Node();
    }

    /** Inserts a word into the trie. */
    void insert(string word) { 
        find(word, true, true); 
    }

    /** Returns if the word is in the trie. */
    bool search(string word) { 
        return find(word, true, false); 
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) { 
        return find(prefix, false, false);
    }

private:
    struct Node {
        int count;
        unordered_map<char, Node*> child;
        Node(): count(0) {}
    };
    Node* root;

    bool find(const string& s, bool exact_match, bool insert_if_not_exist) {
        Node* curr = root;
        for (char c : s) {
            if (curr->child.find(c) == curr->child.end()) {
                if (!insert_if_not_exist) return false;
                curr->child[c] = new Node();
            }
            curr = curr->child[c];
        }
        if (insert_if_not_exist) curr->count++;
        return exact_match ? curr->count > 0 : true;
    }
};
```
#### Java代码模板

```java
//Java
import java.util.HashMap;
class Trie {
    /** Initialize your data structure here. */
    public Trie() {
        root = new Node();
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        find(word, true, true);
    }    

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        return find(word, true, false);
    }    

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return find(prefix, false, false);
    }

    class Node {
        public int count;
        public HashMap<Character, Node> child;
        public Node() { count = 0; child = new HashMap<>(); }
    }
    Node root;

    boolean find(String s, boolean exact_match, boolean insert_if_not_exist) {
        Node curr = root;
        for (Character c : s.toCharArray()) {
            if (!curr.child.containsKey(c)) {
                if (!insert_if_not_exist) return false;
                curr.child.put(c, new Node());
            }
            curr = curr.child.get(c);
        }
        if (insert_if_not_exist) curr.count++;
        return exact_match ? curr.count > 0 : true;
    }
}
```

#### JavaScript代码模板

```javascript
// JavaScript
/**
 * Initialize your data structure here.
 */
var Trie = function() {
    this.root = [0, {}]  // [count, child]
};

Trie.prototype.find = function(word, insertIfNotExist, exactMatch) {
    let curr = this.root
    for (let ch of word) {
        if (!(ch in curr[1])) {
            if (!insertIfNotExist)
                return false
            curr[1][ch] = [0, {}]
        }
        curr = curr[1][ch]
    }
    if (insertIfNotExist)
        curr[0] += 1
    return exactMatch ? curr[0] > 0 : true
};

/**
 * Inserts a word into the trie. 
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
    return this.find(word, true, false);
};

/**
 * Returns if the word is in the trie. 
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
    return this.find(word, false, true);
};

/**
 * Returns if there is any word in the trie that starts with the given prefix. 
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
    return this.find(prefix, false, false);
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */
```

#### Golang代码模板

```go
// Golang

type Trie struct {
    root *node
}

/** Initialize your data structure here. */
func Constructor() Trie {
    return Trie{root: &node{child: make(map[uint8]*node)}}
}

/** Inserts a word into the trie. */
func (this *Trie) Insert(word string) {
    this.find(word, true, true)
}

/** Returns if the word is in the trie. */
func (this *Trie) Search(word string) bool {
    return this.find(word, true, false)
}

/** Returns if there is any word in the trie that starts with the given prefix. */
func (this *Trie) StartsWith(prefix string) bool {
    return this.find(prefix, false, false)
}

type node struct {
    count int
    child map[uint8]*node
}

func (this *Trie) find(s string, exactMatch, insertIfNotExist bool) bool {
    curr := this.root;
    for i := 0; i < len(s); i++ {
        c := s[i]
        if _, ok := curr.child[c]; !ok {
            if !insertIfNotExist {
                return false
            }
            curr.child[c] = &node{child: make(map[uint8]*node)}
        }
        curr = curr.child[c]
    }
    if insertIfNotExist {
        curr.count++
    }
    return !exactMatch || curr.count > 0
}

/**
 * Your Trie object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Insert(word);
 * param_2 := obj.Search(word);
 * param_3 := obj.StartsWith(prefix);
 */
```


### [并查集代码模板](https://shimo.im/docs/cPNO0BMSbWgyDiJ4)
#### Java代码模板

```
// Java
class DisjointSet {
    public DisjointSet(int n) {
        fa = new int[n];
        for (int i = 0; i < n; i++) fa[i] = i;
    }

    public int find(int x) {
        if (x == fa[x]) return x;
        return fa[x] = find(fa[x]);
    }

    public void unionSet(int x, int y) {
        x = find(x);
        y = find(y);
        if (x != y) fa[x] = y;
    }

    int[] fa;
};
```

#### Python代码模板

```
# Python 

class DisjointSet:
    def __init__(self, n):
        self.fa = [i for i in range(n)]
    
    def find(self, x):
        if x == self.fa[x]:
            return x
        self.fa[x] = self.find(self.fa[x])
        return self.fa[x]
    
    def unionSet(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x != y:
            self.fa[x] = y
```

#### C/C++代码模板

```c++
//C/C++
class DisjointSet {
public:
    DisjointSet(int n) {
        fa = vector<int>(n, 0);
        for (int i = 0; i < n; i++) fa[i] = i;
    }

    int find(int x) {
        if (x == fa[x]) return x;
        return fa[x] = find(fa[x]);
    }

    void unionSet(int x, int y) {
        x = find(x), y = find(y);
        if (x != y) fa[x] = y;
    }

private:
    vector<int> fa;
};
```

#### JavaScript代码模板

```javascript
// JavaScript

class DisjointSet {
    constructor(n) {
        this.fa = [];
        for (let i = 0; i < n; i++) this.fa[i] = i;
    }

    find(x) {
        if (x == this.fa[x]) return x;
        return this.fa[x] = this.find(this.fa[x]);
    }

    unionSet(x, y) {
        x = this.find(x);
        y = this.find(y);
        if (x != y) this.fa[x] = y;
    }
};
```

#### Golang代码模板

```go
// Golang
type DisjointSet struct {
    fa []int
}

func Construct(n int) DisjointSet {
    s := DisjointSet{fa: make([]int, n)}
    for i := 0; i < n; i++ {
        s.fa[i] = i
    }
    return s
}

func (s *DisjointSet) Find(x int) int {
    if s.fa[x] != x {
        s.fa[x] = s.Find(s.fa[x])
    }
    return s.fa[x]
}

func (s *DisjointSet) Join(x, y int) {
    x, y = s.Find(x), s.Find(y)
    if x != y {
        s.fa[x] = y
    }
}
```




## 第 8 周

### [ Bellman-Ford 求最短路代码模板](https://shimo.im/docs/Q3RtbhYnhbw18TbT)
#### Python代码模板

```python
# Python
# LeetCode 743
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        dist = [1e9] * (n + 1)
        dist[k] = 0
        for iteration in range(n - 1):
            updated = False
            for i in range(len(times)):
                x = times[i][0]
                y = times[i][1]
                z = times[i][2]
                if dist[y] > dist[x] + z:
                    dist[y] = dist[x] + z
                    updated = True
            if not updated:
                break
        ans = 0
        for i in range(1, n + 1):
            ans = max(ans, dist[i])
        if ans == 1e9:
            ans = -1
        return ans
```

#### C/C++代码模板

```c++
// C/C++
// LeetCode 743
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<int> dist(n + 1, 1e9);
        dist[k] = 0;
        for (int iteration = 1; iteration < n; iteration++) {
            bool updated = false;
            for (int i = 0; i < times.size(); i++) {
                int x = times[i][0];
                int y = times[i][1];
                int z = times[i][2];
                if (dist[y] > dist[x] + z) {
                    dist[y] = dist[x] + z;
                    updated = true;
                }
            }
            if (!updated) break;
        }
        int ans = 0;
        for (int i = 1; i <= n; i++)
            ans = max(ans, dist[i]);
        if (ans == 1e9) ans = -1;
        return ans;
    }
};
```

#### Java代码模板

```java
// Java
// LeetCode 743
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        int[] dist = new int[n + 1];
        for (int i = 1; i <= n; i++) dist[i] = (int)1e9;
        dist[k] = 0;
        for (int iteration = 1; iteration < n; iteration++) {
            boolean updated = false;
            for (int i = 0; i < times.length; i++) {
                int x = times[i][0];
                int y = times[i][1];
                int z = times[i][2];
                if (dist[y] > dist[x] + z) {
                    dist[y] = dist[x] + z;
                    updated = true;
                }
            }
            if (!updated) break;
        }
        int ans = 0;
        for (int i = 1; i <= n; i++)
            ans = Math.max(ans, dist[i]);
        if (ans == 1e9) ans = -1;
        return ans;
    }
}
```

#### JavaScript代码模板

```javascript
/* JavaScript */
// LeetCode 743
/**
 * @param {number[][]} times
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var networkDelayTime = function(times, n, k) {
    dist = []
    for (let i = 1; i <= n; i++) dist[i] = 1e9;
    dist[k] = 0;
    for (let iteration = 1; iteration < n; iteration++) {
        let updated = false;
        for (let i = 0; i < times.length; i++) {
            let x = times[i][0];
            let y = times[i][1];
            let z = times[i][2];
            if (dist[y] > dist[x] + z) {
                dist[y] = dist[x] + z;
                updated = true;
            }
        }
        if (!updated) break;
    }
    let ans = 0;
    for (let i = 1; i <= n; i++)
        ans = Math.max(ans, dist[i]);
    if (ans == 1e9) ans = -1;
    return ans;
};
```

#### Golang代码模板

```go
// LeetCode 743
func networkDelayTime(times [][]int, n int, k int) int {
    dist := make([]int, n + 1)
    for i := 1; i <= n; i++ {
        dist[i] = 1e9
    }
    dist[k] = 0;
    for iteration := 1; iteration < n; iteration++ {
        updated := false
        for i := 0; i < len(times); i++ {
            x := times[i][0]
            y := times[i][1]
            z := times[i][2]
            if dist[y] > dist[x] + z {
                dist[y] = dist[x] + z
                updated = true
            }
        }
        if !updated {
            break
        }
    }
    ans := 0
    for i := 1; i <= n; i++ {
        if ans < dist[i] {
            ans = dist[i]
        }
    }
    if ans == 1e9 {
        ans = -1
    }
    return ans
}
```


### [ Dijkstra 求最短路代码模板](https://shimo.im/docs/eN39dKEKccMfted6)
#### Python代码模板

```python
# Python
# https://www.acwing.com/problem/content/description/852/
from heapq import *

if __name__ == "__main__":
    n, m = map(int,input().split())
    
    ver = [[] for i in range(n + 1)] # 0~n
    edge = [[] for i in range(n + 1)] # 0~n
    dist = [1e9] * (n + 1)
    v = [False] * (n + 1)
    
    # 出边数组建图
    for i in range(m):
        x, y, z = map(int,input().split())
        ver[x].append(y)  # 另一端点
        edge[x].append(z) # 边权

    heap = []
    heappush(heap, (0, 1)) # (距离, 点)
    dist[1] = 0

    # Dijkstra 算法
    while heap:
        distance, x = heappop(heap)
        if v[x]:
            continue
        v[x] = True

        for i in range(len(ver[x])):
            y, z = ver[x][i], edge[x][i]
            if dist[y] > dist[x] + z:
                dist[y] = dist[x] + z
                heappush(heap, (dist[y], y))

    print(dist[n] if dist[n] != 1e9 else -1)
```

#### C/C++代码模板

```c++
// C/C++
// https://www.acwing.com/problem/content/description/852/
#include<bits/stdc++.h>
using namespace std;
const int MAX_N = 150005, MAX_M = 150005;
vector<int> ver[MAX_N]; // 出边数组 - 另一端点
vector<int> edge[MAX_N]; // 出边数组 - 边权
int n, m, d[MAX_N];
bool v[MAX_N];
// pair<-dist[x], x>
priority_queue<pair<int, int>> q;

// 插入一条从x到y长度z的有向边
void add(int x, int y, int z) {
    ver[x].push_back(y);
    edge[x].push_back(z);
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        add(x, y, z);
    }
    memset(d, 0x7f, sizeof(d));
    d[1] = 0;
    q.push(make_pair(0, 1));
    while (!q.empty()) {
        int x = q.top().second;
        q.pop();
        if (v[x]) continue;
        v[x] = true;
        for (int i = 0; i < ver[x].size(); i++) {
            int y = ver[x][i], z = edge[x][i];
            if (d[y] > d[x] + z) {
                d[y] = d[x] + z;
                q.push(make_pair(-d[y], y));
            }
        }
    }
    if (d[n] == 0x7f7f7f7f) puts("-1");
    else cout << d[n] << endl;
}
```

#### Java代码模板

```java
// Java
// https://www.acwing.com/problem/content/description/852/
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String args[]) throws Exception {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int m = input.nextInt();
        
        // 模板：出边数组初始化
        // 初态：[[], [], ... []]
        List<List<Integer>> ver = new ArrayList<List<Integer>>(); // 另一端点
        List<List<Integer>> edge = new ArrayList<List<Integer>>(); // 边权
        boolean[] v = new boolean[n + 1];
        int[] dist = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            ver.add(new ArrayList<Integer>());
            edge.add(new ArrayList<Integer>());
            v[i] = false;
            dist[i] = (int)1e9;
        }

        for (int i = 1; i <= m; i++) {
            int x = input.nextInt();
            int y = input.nextInt();
            int z = input.nextInt();
            // 出边数组 addEdge 模板
            ver.get(x).add(y);
            edge.get(x).add(z);
        }
        
        // Dijkstra算法
        dist[1] = 0;
        // 堆，每个结点是长度为2的数组 [点，dist]
        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> {return a[1] - b[1];});
        q.offer(new int[]{1, 0});
        while(!q.isEmpty()){
            int[] top = q.poll();
            int x = top[0];
            if (v[x]) continue;
            v[x] = true;
            for (int i = 0; i < ver.get(x).size(); i++) {
                int y = ver.get(x).get(i);
                int z = edge.get(x).get(i);
                if (dist[y] > dist[x] + z) {
                    dist[y] = dist[x] + z;
                    q.offer(new int[]{y, dist[y]});
                }
            }
        }
        System.out.println(dist[n] == 1e9 ? -1 : dist[n]);
    }
}
```

#### JavaScript代码模板

```javascript
/* JavaScript */
// https://www.acwing.com/problem/content/description/852/
class BinaryHeap {
    constructor() {
        // 数组存储完全二叉树
        // 从索引0开始存
        this.heap = [];
    }

    swap(i, j) {
        let temp = this.heap[i];
        this.heap[i] = this.heap[j];
        this.heap[j] = temp;
    }

    isEmpty() {
        return this.heap.length == 0;
    }

    push(node) {
        // 插入到尾部
        this.heap.push(node);
        // 向上调整
        this.heapifyUp(this.heap.length - 1);
    }                

    pop() {
        let ans = this.heap[0];
        // 末尾交换到头部，然后删除末尾
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        // 向下调整
        this.heapifyDown(0);
        return ans;
    }

    heapifyUp(p) {        
        while (p > 0) {
            let fa = (p - 1) >> 1;  // 右移1位，等于整除2
            if (this.heap[p].key < this.heap[fa].key) { // 小根堆
                this.swap(p, fa);
                p = fa;
            }
            else break;
        }
    }

    heapifyDown(p) {
        let child = p * 2 + 1;
        while (child < this.heap.length) {  // child未出界，说明p有合法的child，还不是叶子
            let otherChild = p * 2 + 2;
            // 先比较两个孩子，谁小就继续跟p比较
            // child存较小的孩子
            if (otherChild < this.heap.length && this.heap[child].key > this.heap[otherChild].key)
                child = otherChild;
            // 让child跟p比较
            if (this.heap[p].key > this.heap[child].key) { // 小根堆
                this.swap(p, child);
                p = child;
                child = p * 2 + 1;
            }
            else break;
        }
    }
};

let n, m;
// 出边数组
let ver = []; // 另一端点
let edge = []; // 边权

let addEdge = (x, y, z) => {
    ver[x].push(y);
    edge[x].push(z);
}

// Dijkstra算法
let dijkstra = () => {
    let dist = [];
    let v = []
    for (let i = 1; i <= n; i++) {
        dist[i] = 1e9;
        v[i] = false;
    }
    dist[1] = 0;
    let q = new BinaryHeap();
    q.push({key: 0, vertex: 1}); // 距离作为key
    while (!q.isEmpty()) {
        let x = q.pop().vertex;
        if (v[x]) continue;
        v[x] = true;
        for (let i = 0; i < ver[x].length; i++) {
            let y = ver[x][i];
            let z = edge[x][i];
            if (dist[y] > dist[x] + z) {
                dist[y] = dist[x] + z;
                q.push({key: dist[y], vertex: y});
            }
        }
    }
    if (dist[n] === 1e9) return -1;
    return dist[n];
}

// 处理读入
let buf = '';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputNums = line => line.split(' ').filter(s => s !== '').map(x => parseInt(x));
let getInputStr = line => line.split(' ').filter(s => s !== '');

process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
        if (lineIdx === 0) {
            n = getInputNums(line)[0];
            m = getInputNums(line)[1];
            for (let i = 1; i <= n; i++) {
                ver[i] = [];
                edge[i] = [];
            }
        } else if (lineIdx <= m) {
            let arr = getInputNums(line);
            let x = arr[0];
            let y = arr[1];
            let z = arr[2];
            addEdge(x, y, z);
            if (lineIdx === m) {
                console.log(dijkstra());
            }
        }
    });
});

```


#### Golang代码模板

```go
// Go
// https://www.acwing.com/problem/content/description/852/

package main

import (
    "fmt"
)

type Pair struct {
    A, B int
}

type PriorityQueue struct {
    Data []Pair
}

func (q *PriorityQueue) Add (p Pair) {
    q.Data = append(q.Data, p)
    cur := len(q.Data) - 1
    for {
        if cur != 0 && q.Data[cur].A < q.Data[(cur - 1) / 2].A {
            q.Data[cur], q.Data[(cur - 1) / 2] = q.Data[(cur - 1) / 2], q.Data[cur]
            cur = (cur - 1) / 2
        } else {
            return
        }
    }
}

func (q *PriorityQueue) Pop() (res Pair) {
    res = q.Data[0]
    q.Data[0] = q.Data[len(q.Data) - 1]
    q.Data = q.Data[: len(q.Data) - 1]
    cur := 0
    for {
        l, r := cur * 2 + 1, cur * 2 + 2
        if l < len(q.Data) && q.Data[l].A < q.Data[cur].A && (r >= len(q.Data) || q.Data[l].A <= q.Data[r].A) {
            q.Data[cur], q.Data[l] = q.Data[l], q.Data[cur]
            cur = l
        } else if r < len(q.Data) && q.Data[r].A < q.Data[cur].A && (l >= len(q.Data) || q.Data[r].A <= q.Data[l].A) {
            q.Data[cur], q.Data[r] = q.Data[r], q.Data[cur]
            cur = r
        } else {
            return
        }
    }
}

const maxN = 150005

type Edge struct {
    V, W, Nxt int
}
var e = make([]Edge, maxN)
var head = make([]int, maxN)
var cnt = 1

func AddEdge(u, v, w int) {
    e[cnt].V = v
    e[cnt].W = w
    e[cnt].Nxt = head[u]
    head[u] = cnt
    cnt++
}

var n, m int
var dis = make([]int, maxN)
var q = PriorityQueue{Data: make([]Pair, 0)}

func main() {
    for i := range dis {
        dis[i] = -1
    }
    fmt.Scanf("%d %d", &n, &m)
    for ; m > 0; m-- {
        var u, v, w int
        fmt.Scanf("%d %d %d", &u, &v, &w)
        AddEdge(u, v, w)
    }
    dis[1] = 0
    q.Add(Pair{A: 0, B: 1})
    for len(q.Data) > 0 {
        cur := q.Pop()
        if cur.A != dis[cur.B] {
            continue
        } else if cur.B == n {
            break
        }
        for j := head[cur.B]; j != 0; j = e[j].Nxt {
            if dis[e[j].V] == -1 || cur.A + e[j].W < dis[e[j].V] {
                dis[e[j].V] = cur.A + e[j].W
                q.Add(Pair{A: dis[e[j].V], B: e[j].V})
            }
        }
    }
    fmt.Println(dis[n])
}
```



### [Kruskal 求最小生成树代码模板](https://shimo.im/docs/iqbCyldufYANZV52)
#### Python代码模板

```python
# Python
# LeetCode 1584
class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        # 构造出边
        edges = []
        n = len(points)
        for i in range(n):
            for j in range(i + 1, n):
                edges.append([i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])])
        # 按边权排序
        edges.sort(key=lambda e: e[2])
        # Kruskal算法
        self.fa = []
        for i in range(n):
            self.fa.append(i)
        ans = 0
        for e in edges:
            x, y, z = self.find(e[0]), self.find(e[1]), e[2]
            if x != y:
                self.fa[x] = y
                ans += z
        return ans
        
    def find(self, x):
        if x == self.fa[x]:
            return x
        self.fa[x] = self.find(self.fa[x])
        return self.fa[x]
```

#### C/C++代码模板

```c++
// C/C++
// LeetCode 1584
class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        // 构造出边
        vector<vector<int>> edges;
        for (int i = 0; i < points.size(); i++)
            for (int j = i + 1; j < points.size(); j++)
                edges.push_back({i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])});
        // 按照边权排序
        sort(edges.begin(), edges.end(),
             [](const vector<int>& a, const vector<int>&b) {
                 return a[2] < b[2];
             });
        // Kruskal算法
        for (int i = 0; i < points.size(); i++) fa.push_back(i);
        int ans = 0;
        for (int i = 0; i < edges.size(); i++) {
            int x = edges[i][0];
            int y = edges[i][1];
            int z = edges[i][2];
            if (find(x) != find(y)) {
                ans += z;
                fa[find(x)] = find(y);
            }
        }
        return ans;
    }

private:
    vector<int> fa;
    int find(int x) {
        if (x == fa[x]) return x;
        return fa[x] = find(fa[x]);
    }
};
```

#### Java代码模板

```java
// Java
// LeetCode 1584
class Solution {
    public int minCostConnectPoints(int[][] points) {
        // 构造出边
        List<int[]> edges = new ArrayList<>();
        for (int i = 0; i < points.length; i++)
            for (int j = i + 1; j < points.length; j++)
                edges.add(new int[]{i, j, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])});
        // 按照边权排序
        edges.sort((a, b) -> { return a[2] - b[2]; });
        // Kruskal算法
        fa = new int[points.length];
        for (int i = 0; i < points.length; i++) fa[i] = i;
        int ans = 0;
        for (int i = 0; i < edges.size(); i++) {
            int x = edges.get(i)[0];
            int y = edges.get(i)[1];
            int z = edges.get(i)[2];
            if (find(x) != find(y)) {
                ans += z;
                fa[find(x)] = find(y);
            }
        }
        return ans;
    }

    int[] fa;
    int find(int x) {
        if (x == fa[x]) return x;
        return fa[x] = find(fa[x]);
    }
}
```

#### JavaScript代码模板

```javascript
/* JavaScript */
// LeetCode 1584
/**
 * @param {number[][]} points
 * @return {number}
 */
var minCostConnectPoints = function(points) {
    let fa = [];
    for (let i = 0; i < points.length; i++) fa[i] = i;
    var find = function(x) {
        if (x == fa[x]) return x;
        return fa[x] = find(fa[x]);
    }

    // 构造出边
    let edges = [];
    for (let i = 0; i < points.length; i++)
        for (let j = i + 1; j < points.length; j++)
            edges.push([i, j, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])]);
    // 按照边权排序
    edges.sort((a, b) => a[2] - b[2]);
    // Kruskal算法
    let ans = 0;
    for (let e of edges) {
        let [x, y, z] = e;
        if (find(x) != find(y)) {
            ans += z;
            fa[find(x)] = find(y);
        }
    }
    return ans;
};
```

#### Golang代码模板

```go
// Go
// LeetCode 1584
type unionFind struct {
    parent, rank []int
}

func newUnionFind(n int) *unionFind {
    parent := make([]int, n)
    rank := make([]int, n)
    for i := range parent {
        parent[i] = i
        rank[i] = 1
    }
    return &unionFind{parent, rank}
}

func (uf *unionFind) find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *unionFind) union(x, y int) bool {
    fx, fy := uf.find(x), uf.find(y)
    if fx == fy {
        return false
    }
    if uf.rank[fx] < uf.rank[fy] {
        fx, fy = fy, fx
    }
    uf.rank[fx] += uf.rank[fy]
    uf.parent[fy] = fx
    return true
}

func dist(p, q []int) int {
    return abs(p[0]-q[0]) + abs(p[1]-q[1])
}

func minCostConnectPoints(points [][]int) (ans int) {
    n := len(points)
    type edge struct{ v, w, dis int }
    edges := []edge{}
    for i, p := range points {
        for j := i + 1; j < n; j++ {
            edges = append(edges, edge{i, j, dist(p, points[j])})
        }
    }

    sort.Slice(edges, func(i, j int) bool { return edges[i].dis < edges[j].dis })

    uf := newUnionFind(n)
    left := n - 1
    for _, e := range edges {
        if uf.union(e.v, e.w) {
            ans += e.dis
            left--
            if left == 0 {
                break
            }
        }
    }
    return
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```



### [Floyd 求最短路代码模板](https://shimo.im/docs/O7FfFdDzqvoKPb2j)
#### Python代码模板

```python
# Python
# LeetCode 1334
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        # 邻接矩阵初值：i到i长度为0，没有边长度为INF，其余为输入的边
        d = [[1e9] * n for i in range(n)]
        for edge in edges:
            x, y, z = edge[0], edge[1], edge[2]
            d[x][y] = d[y][x] = z
        for i in range(n):
            d[i][i] = 0
        # Floyd算法
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])
        # 统计答案
        ansCount, ans = n, 0
        for i in range(n):
            count = 0
            for j in range(n):
                if i != j and d[i][j] <= distanceThreshold:
                    count += 1
            if count <= ansCount:
                ansCount = count
                ans = i
        return ans
```

#### C/C++代码模板

```c++
// C/C++
// LeetCode 1334
class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        // 邻接矩阵初值：i到i长度为0，没有边长度为INF，其余为输入的边
        vector<vector<int>> d(n, vector<int>(n, 1e9));
        for (auto& edge : edges) {
            int x = edge[0], y = edge[1], z = edge[2];
            d[x][y] = d[y][x] = z;
        }
        for (int i = 0; i < n; i++) d[i][i] = 0;
        // Floyd算法
        for (int k = 0; k < n; k++)
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
        // 统计答案
        int ansCount = n, ans;
        for (int i = 0; i < n; i++) {
            int count = 0;
            for (int j = 0; j < n; j++)
                if (i != j && d[i][j] <= distanceThreshold) count++;
            if (count <= ansCount) {
                ansCount = count;
                ans = i;
            }
        }
        return ans;
    }
};
```

#### Java代码模板

```java
// Java
// LeetCode 1334
class Solution {
    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        // 邻接矩阵初值：i到i长度为0，没有边长度为INF，其余为输入的边
        int[][] d = new int[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                d[i][j] = (int)1e9;
        for (int[] edge : edges) {
            int x = edge[0], y = edge[1], z = edge[2];
            d[x][y] = d[y][x] = z;
        }
        for (int i = 0; i < n; i++) d[i][i] = 0;
        // Floyd算法
        for (int k = 0; k < n; k++)
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);
        // 统计答案
        int ansCount = n, ans = 0;
        for (int i = 0; i < n; i++) {
            int count = 0;
            for (int j = 0; j < n; j++)
                if (i != j && d[i][j] <= distanceThreshold) count++;
            if (count <= ansCount) {
                ansCount = count;
                ans = i;
            }
        }
        return ans;
    }
}
```

#### JavaScript代码模板

```javascript
/* JavaScript */
// LeetCode 1334
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} distanceThreshold
 * @return {number}
 */
var findTheCity = function(n, edges, distanceThreshold) {
    // 邻接矩阵初值：i到i长度为0，没有边长度为INF，其余为输入的边
    let d = [];
    for (let i = 0; i < n; i++) {
        d[i] = [];
        for (let j = 0; j < n; j++) d[i][j] = 1e9;
    }
    for (let edge of edges) {
        let x = edge[0], y = edge[1], z = edge[2];
        d[x][y] = d[y][x] = z;
    }
    for (let i = 0; i < n; i++) d[i][i] = 0;
    // Floyd算法
    for (let k = 0; k < n; k++)
        for (let i = 0; i < n; i++)
            for (let j = 0; j < n; j++)
                d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);
    // 统计答案
    let ansCount = n, ans = 0;
    for (let i = 0; i < n; i++) {
        let count = 0;
        for (let j = 0; j < n; j++)
            if (i != j && d[i][j] <= distanceThreshold) count++;
        if (count <= ansCount) {
            ansCount = count;
            ans = i;
        }
    }
    return ans;
}
```

#### Golang代码模板

```go
// Go
// LeetCode 1334
func findTheCity(n int, edges [][]int, distanceThreshold int) int {
    // 最短路径的状态数组
    var dp [][]int
    // 先初始化
    for i := 0; i < n; i++ {
        var tmp []int
        for j := 0; j < n; j++ { 
            if i == j {
                tmp = append(tmp, 0)
            } else {
                tmp = append(tmp, -1)
            }
        }
        dp = append(dp, tmp)
    }
    // 填出边长
    for i := 0; i < len(edges); i++ {
        from := edges[i][0]
        to := edges[i][1]
        weight := edges[i][2]
        // 无向图
        dp[from][to] = weight
        dp[to][from] = weight
    }
    // dp状态转移方程
    // k放在第一层是因为后面的k要依赖前面的值
    for k := 0; k < n; k++ {
        // 从i到j
        for i := 0; i < n; i++ {
            for j := 0; j < n; j++ {
                // 相同的节点不考虑
                if i == j || i == k || j == k {
                    continue
                }
                // 不通的路也不考虑
                if dp[i][k] == -1 || dp[k][j] == -1 {
                    continue
                }
                tmp := dp[i][k] + dp[k][j]
                if dp[i][j] == -1 || dp[i][j] > tmp {
                    dp[i][j] = tmp
                    dp[j][i] = tmp
                }
            }
        }
    }
    // 统计小于阈值的路径数
    min := n
    idx := 0
    for i := 0; i < n; i++ {
        cnt := 0
        for j := 0; j < n; j++ {
            if i == j {
                continue
            }
            if dp[i][j] <= distanceThreshold {
                cnt++
            }
        }
        if cnt <= min {
            min = cnt
            idx = i
        }
    }
    return idx
}
```



### [ Rabin-Karp 字符串哈希模板](https://shimo.im/docs/ziop0MeHs0MhBdwt)
#### C/C++代码模板

```c++
// C/C++
// LeetCode 28 实现strStr
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        int n = haystack.size();
        int m = needle.size();
        haystack = " " + haystack;
        needle = " " + needle;

        H.push_back(0);
        for (int i = 1; i <= n; i++)
            H.push_back(H[i - 1] * 131 + haystack[i] - 'a' + 1);
        unsigned int val = 0;
        p131.push_back(1);
        for (int i = 1; i <= m; i++) {
            val = val * 131 + needle[i] - 'a' + 1;
            p131.push_back(p131[i - 1] * 131);
        }
        for (int i = m; i <= n; i++) { // 滑动窗结尾
            if (calcHash(i - m + 1, i) == val &&
                haystack.substr(i - m + 1, m) == needle.substr(1, m))
                return i - m; // 下标变回0开始
        }
        return -1;
    }

    // 模板：O(1)得到子串[l..r]的Hash值
    unsigned int calcHash(int l, int r) {
        return H[r] - H[l - 1] * p131[r - l + 1];
    }

private:
    vector<unsigned int> H;
    vector<unsigned int> p131;
};
```

#### Java代码模板

```
// Java
// LeetCode 28 实现strStr
class Solution {
    public int strStr(String s, String t) {
        if (t.length() == 0) return 0;
        int n = s.length();
        int m = t.length();
        s = " " + s;
        t = " " + t;

        int p = (int)1e9 + 7; // 10^9+7 是一个质数
        long tHash = 0;
        for (int i = 1; i <= m; i++)
            tHash = (tHash * 131 + (t.charAt(i) - 'a' + 1)) % p;
        // 模板：预处理前缀Hash
        long[] sHash = new long[n + 1];
        sHash[0] = 0;
        long[] p131 = new long[n + 1]; // 131的次幂
        p131[0] = 1;
        for (int i = 1; i <= n; i++) {
            sHash[i] = (sHash[i - 1] * 131 + s.charAt(i) - 'a' + 1) % p;
            p131[i] = p131[i - 1] * 131 % p;
        }
        // hello
        // ll
        for (int i = m; i <= n; i++) { // 滑动窗结尾
            // s[i-m+1 ~ i] 与 t[1..m] 是否相等
            if (calcHash(sHash, p131, p, i - m + 1, i) == tHash &&
                s.substring(i - m + 1, i + 1).equals(t.substring(1))) {
                return i - m; // 下标变回0开始
            }
        }
        return -1;
    }

    // 模板：O(1)得到子串[l..r]的Hash值
    private long calcHash(long[] H, long[] p131, int p, int l, int r) {
        // hello 的子串ll的hash值
        //  hell
        // -he00
        // =  ll
        return ((H[r] - H[l - 1] * p131[r - l + 1]) % p + p) % p;
    }
}
```


#### Python代码模板

```
# Python
# LeetCode 28 实现strStr
class Solution:
    def strStr(self, s: str, t: str) -> int:
        if len(t) == 0:
            return 0
        n, m = len(s), len(t)
        s = " " + s
        t = " " + t

        p = int(1e9 + 7)
        tHash = 0
        for i in range(1, m + 1):
            tHash = (tHash * 13331 + ord(t[i])) % p
        # 模板：预处理前缀Hash
        sHash = [0] * (n + 1)
        p13331 = [1] + [0] * n
        for i in range(1, n + 1):
            sHash[i] = (sHash[i - 1] * 13331 + ord(s[i])) % p
            p13331[i] = p13331[i - 1] * 13331 % p

        # 模板：O(1)得到子串[l..r]的Hash值
        # hello 的子串ll的hash值
        #  hell
        # -he00
        # =  ll
        calcHash = lambda l, r: ((sHash[r] - sHash[l - 1] * p13331[r - l + 1]) % p + p) % p
    
        for i in range(m, n + 1): # 滑动窗结尾
            print(calcHash(i - m + 1, i))
            # s[i-m+1 ~ i] 与 t[1..m] 是否相等
            if calcHash(i - m + 1, i) == tHash and s[i - m + 1 : i + 1] == t[1:]:
                return i - m; # 下标变回0开始
        return -1
```

#### JavaScript代码模板

```javascript
// JavaScript
// LeetCode 28 实现strStr
/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var strStr = function(s, t) {

    if (t.length == 0) return 0;
    let n = s.length;
    let m = t.length;
    s = " " + s;
    t = " " + t;

    const p =  9999991; // 9999991 是一个质数，JavaScript整数没有long，模数不能开太大
    let tHash = 0;
    for (let i = 1; i <= m; i++)
        tHash = (tHash * 13331 + t.charCodeAt(i)) % p;
    // 模板：预处理前缀Hash
    let sHash = [];
    sHash[0] = 0;
    let p13331 = []; // 13331的次幂
    p13331[0] = 1;
    for (let i = 1; i <= n; i++) {
        sHash[i] = (sHash[i - 1] * 13331 + s.charCodeAt(i)) % p;
        p13331[i] = p13331[i - 1] * 13331 % p;
    }

    // 模板：O(1)得到子串[l..r]的Hash值
    var calcHash = function(l, r) {
        // hello 的子串ll的hash值
        //  hell
        // -he00
        // =  ll
        return ((sHash[r] - sHash[l - 1] * p13331[r - l + 1]) % p + p) % p;
    }
  
    for (let i = m; i <= n; i++) { // 滑动窗结尾
        // s[i-m+1 ~ i] 与 t[1..m] 是否相等
        if (calcHash(i - m + 1, i) == tHash &&
            s.substring(i - m + 1, i + 1) == t.substring(1)) {
            return i - m; // 下标变回0开始
        }
    }
    return -1;
};
```

#### Golang代码模板

```go
// Golang
// LeetCode 28 实现strStr
func strStr(s, t string) int {
    if t == "" {
        return 0
    }
    n, m := len(s), len(t)
    s = " " + s
    t = " " + t

    p := int64(1e9 + 7) // 10^9+7 是一个质数
    var tHash int64 = 0
    for i := 1; i <= m; i++ {
        tHash = (tHash * 131 + (int64(t[i]) - 'a' + 1)) % p
    }
            
        // 模板：预处理前缀Hash
    sHash := make([]int64, n + 1)
    sHash[0] = 0
    p131 := make([]int64, n + 1) // 131的次幂
    p131[0] = 1;
    for i := 1; i <= n; i++ {
        sHash[i] = (sHash[i - 1] * 131 + (int64(s[i]) - 'a' + 1)) % p
        p131[i] = p131[i - 1] * 131 % p
    }
    // hello
    // ll
    for i := m; i <= n; i++ { // 滑动窗结尾
        // s[i-m+1 ~ i] 与 t[1..m] 是否相等
        if calcHash(sHash, p131, p, i - m + 1, i) == tHash &&
        s[i - m + 1: i + 1] == t[1: ] {
            return i - m // 下标变回0开始
        }
    }
    return -1
}

// 模板：O(1)得到子串[l..r]的Hash值
func calcHash(H, p131 []int64, p int64, l, r int) int64 {
    // hello 的子串ll的hash值
    //  hell
    // -he00
    // =  ll
    return ((H[r] - H[l - 1] * p131[r - l + 1]) % p + p) % p
}
```


### [字符串转整数代码示例](https://shimo.im/docs/IrGauTVR0U0aMdIf)
#### C/C++代码模板

```c++
//C/C++
class Solution {
public:
    int myAtoi(string s) {
        // i----->
        int index = 0;
        // 1. while 丢弃前导空格
        while (index < s.length() && s[index] == ' ') index++;
        // 2. if 判断符号
        int sign = 1;
        if (index < s.length() && (s[index] == '+' || s[index] == '-')) {
            if (s[index] == '-') sign = -1;
            index++;
        }
        // 3. while 处理数字
        int val = 0;
        // ASCII table
        // ASCII码 '0'-'9'是相连的
        while (index < s.length() && (s[index] >= '0' && s[index] <= '9')) {
            //    (a) if 数值范围
            // if (val * 10 + (s[index] - '0') > 2147483647) 移项
            if (val > (2147483647 - (s[index] - '0')) / 10) {
                if (sign == -1) return -2147483648;
                else return 2147483647;
            }
            val = val * 10 + (s[index] - '0');
            index++;
        }
        // 4. 终止条件：遇到非数字停止
        // 已经体现在while循环中
        return val * sign;
    }
};
```

#### Java代码模板

```
// Java
public int myAtoi(String str) {
    int index = 0, sign = 1, total = 0;
    //1. Empty string
    if(str.length() == 0) return 0;

    //2. Remove Spaces
    while(str.charAt(index) == ' ' && index < str.length())
        index ++;

    //3. Handle signs
    if(str.charAt(index) == '+' || str.charAt(index) == '-'){
        sign = str.charAt(index) == '+' ? 1 : -1;
        index ++;
    }
    
    //4. Convert number and avoid overflow
    while(index < str.length()){
        int digit = str.charAt(index) - '0';
        if(digit < 0 || digit > 9) break;

        //check if total will be overflow after 10 times and add digit
        if(Integer.MAX_VALUE/10 < total ||            
        	Integer.MAX_VALUE/10 == total && Integer.MAX_VALUE %10 < digit)
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;

        total = 10 * total + digit;
        index ++;
    }
    return total * sign;
}
```


#### Python代码模板

```
# Python
class Solution(object):

    def myAtoi(self, s):

        if len(s) == 0 : return 0
        ls = list(s.strip())
        
        sign = -1 if ls[0] == '-' else 1

        if ls[0] in ['-','+'] : del ls[0]

        ret, i = 0, 0

        while i < len(ls) and ls[i].isdigit() :
            ret = ret*10 + ord(ls[i]) - ord('0')
            i += 1

        return max(-2**31, min(sign * ret,2**31-1))
```

#### JavaScript代码模板

```javascript
// JavaScript
function myAtoi(str) {
  let index = 0;
  let sign = 1;
  let total = 0;
  // 1. Empty String
  if (str.length === 0) return 0;

  // 2. trim
  while (str[index] === " " && index < str.length) {
    index++;
  }

  // 3. get sign
  if (str[index] === "+" || str[index] === "-") {
    sign = str[index] === "+" ? 1 : -1;
    index++;
  }

  // 4. covert
  while (index < str.length) {
    let digit = str[index].codePointAt(0) - "0".codePointAt(0);
    if (digit < 0 || digit > 9) break;
    total = total * 10 + digit;
    index++;
  }

  if (sign * total > 2 ** 31 - 1) {
    return 2 ** 31 - 1;
  } else {
  }

  return Math.max(Math.min(sign * total, 2 ** 31 - 1), -(2 ** 31)
```

#### Golang代码模板

```c++
// Golang
func myAtoi(s string) int {
    // i----->
    index := 0
    // 1. while 丢弃前导空格
    for index < len(s) && s[index] == ' ' {
        index++
    }
    sign := 1
    for index < len(s) && (s[index] == '+' || s[index] == '-') {
        if (s[index] == '-') {
            sign = -1
        }
        index++
    }
    // 3. while 处理数字
    val := 0
    // ASCII table
    // ASCII码 '0'-'9'是相连的
    for index < len(s) && (s[index] >= '0' && s[index] <= '9') {
        //    (a) if 数值范围
        // if (val * 10 + (s[index] - '0') > 2147483647) 移项
        if val > (2147483647 - (int(s[index]) - '0')) / 10 {
            if (sign == -1) {
                return -2147483648
            } else {
                return 2147483647
            }
        }
        val = val * 10 + (int(s[index]) - '0')
        index++
    }
    // 4. 终止条件：遇到非数字停止
    // 已经体现在while循环中
    return val * sign
}
```




## 第 9 周

### [ KMP 字符串匹配模板](https://shimo.im/docs/BGrEdqTYy0QVu73A)

#### C/C++代码模板

```c++
// C/C++
// LeetCode 28 实现strStr
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        int n = haystack.length();
        int m = needle.length();
        vector<int> next(m, -1); // 下标从0开始，初值-1；下标从1开始，初值0。
        for (int i = 1, j = -1; i < m; i++) {
            while (j >= 0 && needle[j + 1] != needle[i]) j = next[j];
            if (needle[j + 1] == needle[i]) j++;
            next[i] = j;
        }
        for (int i = 0, j = -1; i < n; i++) {
            while (j >= 0 && needle[j + 1] != haystack[i]) j = next[j];
            if (j + 1 < m && needle[j + 1] == haystack[i]) j++;
            if (j + 1 == m) return i - m + 1;
        }
        return -1;
    }
};
```

## 
#### Java代码模板

```
// Java
// LeetCode 28 实现strStr
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        int n = haystack.length();
        int m = needle.length();
        int[] next = new int[m];
        for (int i = 0; i < m; i++) next[i] = -1; // 下标从0开始，初值-1；下标从1开始，初值0。
        for (int i = 1, j = -1; i < m; i++) {
            while (j >= 0 && needle.charAt(j + 1) != needle.charAt(i)) j = next[j];
            if (needle.charAt(j + 1) == needle.charAt(i)) j++;
            next[i] = j;
        }
        for (int i = 0, j = -1; i < n; i++) {
            while (j >= 0 && needle.charAt(j + 1) != haystack.charAt(i)) j = next[j];
            if (j + 1 < m && needle.charAt(j + 1) == haystack.charAt(i)) j++;
            if (j + 1 == m) return i - m + 1;
        }
        return -1;
    }
}
```


#### Python代码模板

```
# Python
# LeetCode 28 实现strStr
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if len(needle) == 0:
            return 0
        n, m = len(haystack), len(needle)
        next = [-1] * m  # 下标从0开始，初值-1；下标从1开始，初值0。
        j = -1
        for i in range(1, m):
            while j >= 0 and needle[j + 1] != needle[i]:
                j = next[j]
            if needle[j + 1] == needle[i]:
                j += 1
            next[i] = j
        j = -1
        for i in range(n):
            while j >= 0 and needle[j + 1] != haystack[i]:
                j = next[j]
            if j + 1 < m and needle[j + 1] == haystack[i]:
                j += 1
            if j + 1 == m:
                return i - m + 1
        return -1
```

#### JavaScript代码模板

```javascript
// JavaScript
// LeetCode 28 实现strStr
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
        if (needle.length == 0) return 0;
        const n = haystack.length;
        const m = needle.length;
        let next = [];
        for (let i = 0; i < m; i++) next[i] = -1; // 下标从0开始，初值-1；下标从1开始，初值0。
        for (let i = 1, j = -1; i < m; i++) {
            while (j >= 0 && needle[j + 1] != needle[i]) j = next[j];
            if (needle[j + 1] == needle[i]) j++;
            next[i] = j;
        }
        for (let i = 0, j = -1; i < n; i++) {
            while (j >= 0 && needle[j + 1] != haystack[i]) j = next[j];
            if (j + 1 < m && needle[j + 1] == haystack[i]) j++;
            if (j + 1 == m) return i - m + 1;
        }
        return -1;
};
```
#### Golang代码模板

```go
func strStr(haystack string, needle string) int {



	n,m:= len(haystack),len(needle)
    if m==0{
        return 0
    }
	next:=make([]int,m)
	for i,j := 1,0; i < m; i++ {
		for j>0&&needle[i]!=needle[j] {
			j=next[j-1]
		}
		if needle[i]==needle[j]{
			j++
		}

		next[i]=j
	}
	for i,j:= 0,0; i < n; i++ {
		for j>0&&needle[j]!=haystack[i] {
			j=next[j-1]
		}
		if needle[j]==haystack[i]{
			j++;
		}
		if j==m{
			return i-m+1
		}
		
		}

       return -1
}
```


## 第 10 周

### [树状数组代码模板](https://shimo.im/docs/3YrhPHyrtjYVHchk)
#### C/C++代码模板

```c++
class BinaryIndexedTree {
public:
    BinaryIndexedTree(vector<int>& nums) {
        n = nums.size();
        a = c = vector<int>(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            a[i] = nums[i - 1];
            add(i, a[i]);
        }
    }

    void add(int pos, int delta) {
        for (; pos <= n; pos += pos & -pos) c[pos] += delta;
    }

    int get(int index) {
        return a[index];
    }

    void set(int index, int value) {
        a[index] = value;
    }

    int sumPrefix(int pos) {
        int ans = 0;
        for (; pos > 0; pos -= pos & -pos) ans += c[pos];
        return ans;
    }

private:
    int n;
    vector<int> a;
    vector<int> c;
};

class NumArray {
public:
    NumArray(vector<int>& nums)  : tree(BinaryIndexedTree(nums)) {
    }
    
    void update(int index, int val) {
        index++;
        tree.add(index, val - tree.get(index));
        tree.set(index, val);
    }
    
    int sumRange(int left, int right) {
        left++, right++;
        return tree.sumPrefix(right) - tree.sumPrefix(left - 1);
    }

    BinaryIndexedTree tree;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * obj->update(index,val);
 * int param_2 = obj->sumRange(left,right);
 */
```
#### JavaScript代码模板

```javascript
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.n = nums.length;
    this.c = [];
    for (let i = 0; i <= this.n; i++) {
        this.c[i] = 0;
    }
    this.a = [];
    for (let i = 1; i <= this.n; i++) {
        this.a[i] = nums[i - 1]; // 下标变为从1开始
        this.add(i, this.a[i]);
    }
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(index, val) {
    index++; // 下标从1开始
    let delta = val - this.a[index];
    this.add(index, delta);
    this.a[index] = val;
};

/** 
 * @param {number} left 
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {
    left++; right++; // 下标从1开始
    return this.query(right) - this.query(left - 1);
}

NumArray.prototype.query = function(x) {
    let ans = 0;
    for (; x > 0; x -= this.lowbit(x)) ans += this.c[x];
    return ans;
};

NumArray.prototype.add = function(x, delta) {
    for (; x <= this.n; x += this.lowbit(x)) this.c[x] += delta;
}

NumArray.prototype.lowbit = function(x) {
    return x & (-x);
}
/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(index,val);
 * int param_2 = obj.sumRange(left,right);
 */

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(index,val)
 * var param_2 = obj.sumRange(left,right)
 */
```
#### Java代码模板

```java
class NumArray {

    public NumArray(int[] nums) {
        n = nums.length;
        a = new int[n + 1]; // 1~n
        c = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = nums[i - 1]; // 下标变为从1开始
            add(i, a[i]);
        }
    }
    
    public void update(int index, int val) {
        index++; // 下标从1开始
        int delta = val - a[index];
        add(index, delta);
        a[index] = val;
    }
    
    public int sumRange(int left, int right) {
        left++; right++; // 下标从1开始
        return query(right) - query(left - 1);
    }

    int query(int x) {
        int ans = 0;
        for (; x > 0; x -= lowbit(x)) ans += c[x];
        return ans;
    }

    void add(int x, int delta) {
        for (; x <= n; x += lowbit(x)) c[x] += delta;
    }

    int lowbit(int x) {
        return x & (-x);
    }

    int n;
    int[] a;
    int[] c;
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(index,val);
 * int param_2 = obj.sumRange(left,right);
 */
```
#### Python代码模板

```python
class BinaryIndexedTree:
    def __init__(self, nums):
        self.n = len(nums)
        self.a = [0] * (self.n + 1)
        self.c = [0] * (self.n + 1)
        for i in range(1, self.n + 1):
            self.a[i] = nums[i - 1]
            self.add(i, self.a[i])

    def add(self, pos, delta):
        while pos <= self.n:
            self.c[pos] += delta
            pos += pos & -pos

    def get(self, index):
        return self.a[index]

    def set(self, index, value):
        self.a[index] = value

    def sumPrefix(self, pos):
        ans = 0
        while pos > 0:
            ans += self.c[pos]
            pos -= pos & -pos
        return ans

class NumArray:

    def __init__(self, nums: List[int]):
        self.tree = BinaryIndexedTree(nums)



    def update(self, index: int, val: int) -> None:
        index += 1
        self.tree.add(index, val - self.tree.get(index))
        self.tree.set(index, val)

    def sumRange(self, left: int, right: int) -> int:
        left += 1
        right += 1
        return self.tree.sumPrefix(right) - self.tree.sumPrefix(left - 1)





# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(index,val)
# param_2 = obj.sumRange(left,right)
```

#### Golang代码模板

```go
type NumArray struct {
	data []int
}

func Constructor(nums []int) NumArray {
	a := NumArray{
		data: make([]int, len(nums) + 1),
	}
	for i := range nums {
		a.Update(i, nums[i])
	}
	return a
}

func (this *NumArray) Update(index int, val int) {
	x := this.SumRange(index, index)
	index++
	for index < len(this.data) {
		this.data[index] += val - x
		index += index & (-index)
	}
}

func (this *NumArray) SumRange(left int, right int) int {
	right++
	l, r := 0, 0
	for left > 0 {
		l += this.data[left]
		left -= left & (-left)
	}
	for right > 0 {
		r += this.data[right]
		right -= right & (-right)
	}
	return r - l
}
```


### [线段树代码模板](https://shimo.im/docs/9RWVg6KtKDYhJKgH)
#### C/C++代码模板

```c++
class SegmentTree {
public:
    SegmentTree(vector<int>& nums) {
        n = nums.size();
        a = vector<Node>(4 * n);
        build(1, 0, n - 1, nums);
    }

    void Change(int index, int val) {
        change(1, index, val);
    }

    int Query(int left, int right) {
        return query(1, left, right);
    }

private:
    struct Node {
        int l, r;
        int sum;
        int mark; // 标记：曾经想加mark，还没加，之后需要填坑
    };

    // 递归建树
    void build(int curr, int l, int r, vector<int>& nums) {
        a[curr].l = l;
        a[curr].r = r;
        a[curr].mark = 0;
        // 递归边界：叶子
        if (l == r) {
            a[curr].sum = nums[l];
            return;
        }
        int mid = (l + r) / 2;
        // 分两半，递归
        build(curr * 2, l, mid, nums);
        build(curr * 2 + 1, mid + 1, r, nums);
        // 回溯时，自底向上统计信息
        a[curr].sum = a[curr * 2].sum + a[curr * 2 + 1].sum;
    }

    // 单点修改：先递归找到，然后自底向上统计信息
    void change(int curr, int index, int val) {
        // 递归边界：叶子[index, index]
        if (a[curr].l == a[curr].r) {
            a[curr].sum = val;
            return;
        }
        spread(curr);
        int mid = (a[curr].l + a[curr].r) / 2;
        if (index <= mid) change(curr * 2, index, val);
        else change(curr * 2 + 1, index, val);
        a[curr].sum = a[curr * 2].sum + a[curr * 2 + 1].sum;
    }

    // 递归求区间和
    // 完全包含：直接返回
    // 否则：左右划分
    int query(int curr, int l, int r) {
        // 查询的是  [l     ,     r]
        // curr结点是[a[curr].l, a[curr].r]
        // l  a[curr].l  a[curr].r  r
        if (l <= a[curr].l && r >= a[curr].r) return a[curr].sum;
        spread(curr);
        int mid = (a[curr].l + a[curr].r) / 2;
        int ans = 0;
        if (l <= mid) ans += query(curr * 2, l, r);
        if (r > mid) ans += query(curr * 2 + 1, l, r);
        return ans;
    }

    // 区间修改
    void change(int curr, int l, int r, int delta) {
        // 完全包含
        if (l <= a[curr].l && r >= a[curr].r) {
            // 修改这个被完全包含的区间的信息
            a[curr].sum += delta * (a[curr].r - a[curr].l + 1);
            // 子树不改了，有bug，标记一下
            a[curr].mark += delta;
            return;
        }
        spread(curr);
        int mid = (a[curr].l + a[curr].r) / 2;
        if (l <= mid) change(curr * 2, l, r, delta);
        if (r > mid) change(curr * 2 + 1, l, r, delta);
        a[curr].sum = a[curr * 2].sum + a[curr * 2 + 1].sum;
    }

    void spread(int curr) {
        if (a[curr].mark != 0) { // 有bug标记
            a[curr * 2].sum += a[curr].mark * (a[curr * 2].r - a[curr * 2].l + 1);
            a[curr * 2].mark += a[curr].mark;
            a[curr * 2 + 1].sum += a[curr].mark * (a[curr * 2 + 1].r - a[curr * 2 + 1].l + 1);
            a[curr * 2 + 1].mark += a[curr].mark;
            a[curr].mark = 0;
        }
    }

    int n;
    vector<Node> a; // 长4N的数组，存线段树
};

class NumArray {
public:
    NumArray(vector<int>& nums) : tree(SegmentTree(nums)) {
    }
    
    void update(int index, int val) {
        tree.Change(index, val);
    }
    
    int sumRange(int left, int right) {
        return tree.Query(left, right);
    }

    SegmentTree tree;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * obj->update(index,val);
 * int param_2 = obj->sumRange(left,right);
 */
```
Java代码模板

```java
class SegmentTree {
    public SegmentTree(int[] nums) {
        n = nums.length;
        a = new Node[4 * n];
        build(1, 0, n - 1, nums);
    }

    public void Change(int index, int val) {
        change(1, index, val);
    }

    public int Query(int left, int right) {
        return query(1, left, right);
    }

    public class Node {
        int l, r;
        int sum;
        int mark; // 标记：曾经想加mark，还没加，之后需要填坑
    };

    // 递归建树
    void build(int curr, int l, int r, int[] nums) {
        a[curr] = new Node();
        a[curr].l = l;
        a[curr].r = r;
        a[curr].mark = 0;
        // 递归边界：叶子
        if (l == r) {
            a[curr].sum = nums[l];
            return;
        }
        int mid = (l + r) / 2;
        // 分两半，递归
        build(curr * 2, l, mid, nums);
        build(curr * 2 + 1, mid + 1, r, nums);
        // 回溯时，自底向上统计信息
        a[curr].sum = a[curr * 2].sum + a[curr * 2 + 1].sum;
    }

    // 单点修改：先递归找到，然后自底向上统计信息
    void change(int curr, int index, int val) {
        // 递归边界：叶子[index, index]
        if (a[curr].l == a[curr].r) {
            a[curr].sum = val;
            return;
        }
        spread(curr);
        int mid = (a[curr].l + a[curr].r) / 2;
        if (index <= mid) change(curr * 2, index, val);
        else change(curr * 2 + 1, index, val);
        a[curr].sum = a[curr * 2].sum + a[curr * 2 + 1].sum;
    }

    // 递归求区间和
    // 完全包含：直接返回
    // 否则：左右划分
    int query(int curr, int l, int r) {
        // 查询的是  [l     ,     r]
        // curr结点是[a[curr].l, a[curr].r]
        // l  a[curr].l  a[curr].r  r
        if (l <= a[curr].l && r >= a[curr].r) return a[curr].sum;
        spread(curr);
        int mid = (a[curr].l + a[curr].r) / 2;
        int ans = 0;
        if (l <= mid) ans += query(curr * 2, l, r);
        if (r > mid) ans += query(curr * 2 + 1, l, r);
        return ans;
    }

    // 区间修改
    void change(int curr, int l, int r, int delta) {
        // 完全包含
        if (l <= a[curr].l && r >= a[curr].r) {
            // 修改这个被完全包含的区间的信息
            a[curr].sum += delta * (a[curr].r - a[curr].l + 1);
            // 子树不改了，有bug，标记一下
            a[curr].mark += delta;
            return;
        }
        spread(curr);
        int mid = (a[curr].l + a[curr].r) / 2;
        if (l <= mid) change(curr * 2, l, r, delta);
        if (r > mid) change(curr * 2 + 1, l, r, delta);
        a[curr].sum = a[curr * 2].sum + a[curr * 2 + 1].sum;
    }

    void spread(int curr) {
        if (a[curr].mark != 0) { // 有bug标记
            a[curr * 2].sum += a[curr].mark * (a[curr * 2].r - a[curr * 2].l + 1);
            a[curr * 2].mark += a[curr].mark;
            a[curr * 2 + 1].sum += a[curr].mark * (a[curr * 2 + 1].r - a[curr * 2 + 1].l + 1);
            a[curr * 2 + 1].mark += a[curr].mark;
            a[curr].mark = 0;
        }
    }

    int n;
    Node[] a; // 长4N的数组，存线段树
};

class NumArray {

    public NumArray(int[] nums) {
        tree = new SegmentTree(nums);
    }
    
    public void update(int index, int val) {
        tree.Change(index, val);
    }
    
    public int sumRange(int left, int right) {
        return tree.Query(left, right);
    }

    SegmentTree tree;
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(index,val);
 * int param_2 = obj.sumRange(left,right);
 */
```
#### JavaScript代码模板

```javascript
var SegmentTree = function(nums) {
    let n = nums.length;
    this.a = [];
    this.build(1, 0, n - 1, nums);
};

SegmentTree.prototype.Change = function(index, val) {
    this.change(1, index, val);
};

SegmentTree.prototype.Query = function(left, right) {
    return this.query(1, left, right);
};

// 递归建树
SegmentTree.prototype.build = function(curr, l, r, nums) {
    this.a[curr] = {
        l: l,
        r: r,
        mark: 0,
        sum: 0
    };
    // 递归边界：叶子
    if (l == r) {
        this.a[curr].sum = nums[l];
        return;
    }
    let mid = (l + r) >> 1;
    // 分两半，递归
    this.build(curr * 2, l, mid, nums);
    this.build(curr * 2 + 1, mid + 1, r, nums);
    // 回溯时，自底向上统计信息
    this.a[curr].sum = this.a[curr * 2].sum + this.a[curr * 2 + 1].sum;
};

// 单点修改：先递归找到，然后自底向上统计信息
SegmentTree.prototype.change = function(curr, index, val) {
    // 递归边界：叶子[index, index]
    if (this.a[curr].l == this.a[curr].r) {
        this.a[curr].sum = val;
        return;
    }
    this.spread(curr);
    let mid = (this.a[curr].l + this.a[curr].r) >> 1;
    if (index <= mid) this.change(curr * 2, index, val);
    else this.change(curr * 2 + 1, index, val);
    this.a[curr].sum = this.a[curr * 2].sum + this.a[curr * 2 + 1].sum;
};

// 递归求区间和
// 完全包含：直接返回
// 否则：左右划分
SegmentTree.prototype.query = function(curr, l, r) {
    // 查询的是  [l     ,     r]
    // curr结点是[a[curr].l, a[curr].r]
    // l  a[curr].l  a[curr].r  r
    if (l <= this.a[curr].l && r >= this.a[curr].r) return this.a[curr].sum;
    this.spread(curr);
    let mid = (this.a[curr].l + this.a[curr].r) >> 1;
    let ans = 0;
    if (l <= mid) ans += this.query(curr * 2, l, r);
    if (r > mid) ans += this.query(curr * 2 + 1, l, r);
    return ans;
};

// 区间修改
SegmentTree.prototype.changeRange = function(curr, l, r, delta) {
    // 完全包含
    if (l <= this.a[curr].l && r >= this.a[curr].r) {
        // 修改这个被完全包含的区间的信息
        this.a[curr].sum += delta * (this.a[curr].r - this.a[curr].l + 1);
        // 子树不改了，有bug，标记一下
        this.a[curr].mark += delta;
        return;
    }
    this.spread(curr);
    let mid = (this.a[curr].l + this.a[curr].r) >> 1;
    if (l <= mid) this.changeRange(curr * 2, l, r, delta);
    if (r > mid) this.changeRange(curr * 2 + 1, l, r, delta);
    this.a[curr].sum = this.a[curr * 2].sum + this.a[curr * 2 + 1].sum;
};

SegmentTree.prototype.spread = function(curr) {
    if (this.a[curr].mark != 0) { // 有bug标记
        this.a[curr * 2].sum += this.a[curr].mark * (this.a[curr * 2].r - this.a[curr * 2].l + 1);
        this.a[curr * 2].mark += this.a[curr].mark;
        this.a[curr * 2 + 1].sum += this.a[curr].mark * (this.a[curr * 2 + 1].r - this.a[curr * 2 + 1].l + 1);
        this.a[curr * 2 + 1].mark += this.a[curr].mark;
        this.a[curr].mark = 0;
    }
};

var NumArray = function(nums) {
    this.tree = new SegmentTree(nums);
};

NumArray.prototype.update = function(index, val) {
    this.tree.Change(index, val);
};

NumArray.prototype.sumRange = function(left, right) {
    return this.tree.Query(left, right);
};



/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(index,val);
 * int param_2 = obj.sumRange(left,right);
 */
```
#### Python代码模板

```python
class Node:
    def __init__(self):
        self.l = self.r = self.sum = self.mark = 0

class SegmentTree:
    def __init__(self, nums):
        n = len(nums)
        self.a = [Node() for i in range(4 * n)]
        self.build(1, 0, n - 1, nums)

    def Change(self, index, val):
        self.change(1, index, val)

    def Query(self, left, right):
        return self.query(1, left, right)

    # 递归建树
    def build(self, curr, l, r, nums):
        self.a[curr].l = l
        self.a[curr].r = r
        self.a[curr].mark = 0
        # 递归边界：叶子
        if l == r:
            self.a[curr].sum = nums[l]
            return
        mid = (l + r) >> 1
        # 分两半，递归
        self.build(curr * 2, l, mid, nums)
        self.build(curr * 2 + 1, mid + 1, r, nums)
        # 回溯时，自底向上统计信息
        self.a[curr].sum = self.a[curr * 2].sum + self.a[curr * 2 + 1].sum

    # 单点修改：先递归找到，然后自底向上统计信息
    def change(self, curr, index, val):
        # 递归边界：叶子[index, index]
        if self.a[curr].l == self.a[curr].r:
            self.a[curr].sum = val
            return
        self.spread(curr)
        mid = (self.a[curr].l + self.a[curr].r) >> 1
        if index <= mid:
            self.change(curr * 2, index, val)
        else:
            self.change(curr * 2 + 1, index, val)
        self.a[curr].sum = self.a[curr * 2].sum + self.a[curr * 2 + 1].sum

    # 递归求区间和
    # 完全包含：直接返回
    # 否则：左右划分
    def query(self, curr, l, r):
        # 查询的是  [l     ,     r]
        # curr结点是[a[curr].l, a[curr].r]
        # l  a[curr].l  a[curr].r  r
        if l <= self.a[curr].l and r >= self.a[curr].r:
            return self.a[curr].sum
        self.spread(curr)
        mid = (self.a[curr].l + self.a[curr].r) >> 1
        ans = 0
        if l <= mid:
            ans += self.query(curr * 2, l, r)
        if r > mid:
            ans += self.query(curr * 2 + 1, l, r)
        return ans

    # 区间修改
    def changeRange(self, curr, l, r, delta):
        # 完全包含
        if l <= self.a[curr].l and r >= self.a[curr].r:
            # 修改这个被完全包含的区间的信息
            self.a[curr].sum += delta * (self.a[curr].r - self.a[curr].l + 1)
            # 子树不改了，有bug，标记一下
            self.a[curr].mark += delta
            return
        self.spread(curr)
        mid = (self.a[curr].l + self.a[curr].r) >> 1
        if l <= mid:
            self.changeRange(curr * 2, l, r, delta)
        if r > mid:
            self.changeRange(curr * 2 + 1, l, r, delta)
        self.a[curr].sum = self.a[curr * 2].sum + self.a[curr * 2 + 1].sum

    def spread(self, curr):
        if self.a[curr].mark != 0:
            self.a[curr * 2].sum += self.a[curr].mark * (self.a[curr * 2].r - self.a[curr * 2].l + 1)
            self.a[curr * 2].mark += self.a[curr].mark
            self.a[curr * 2 + 1].sum += self.a[curr].mark * (self.a[curr * 2 + 1].r - self.a[curr * 2 + 1].l + 1)
            self.a[curr * 2 + 1].mark += self.a[curr].mark
            self.a[curr].mark = 0



class NumArray:

    def __init__(self, nums: List[int]):
        self.tree = SegmentTree(nums)



    def update(self, index: int, val: int) -> None:
        self.tree.Change(index, val)

    def sumRange(self, left: int, right: int) -> int:
        return self.tree.Query(left, right)





# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(index,val)
# param_2 = obj.sumRange(left,right)
```

#### Golang代码模板

```go
package st

import (
    "errors"
    "fmt"
)

type SegmentTree struct {
    tree []int //线段树
    a    []int //数组数据
}

func leftChild(i int) int {
    return 2*i + 1
}

// 传入一个数组arrs和一个功能函数func,根据功能函数返回一个线段树
func NewSegmentTree(arrs []int) *SegmentTree {
    length := len(arrs)
    tree := &SegmentTree{
        tree: make([]int, length*4),
        a:    arrs,
    }
    tree.build(0, 0, length-1)
    return tree
}

// 在tree的index位置创建 arrs [ l 到 r ]  的线段树
func (tree *SegmentTree) build(index, l, r int) int {
    // 递归终止条件
    if l == r {
        tree.tree[index] = tree.a[l]
        return tree.a[l]
    }
    // 递归过程
    leftI := leftChild(index)
    rightI := leftI + 1
    mid := l + (r-l)/2
    leftResp := tree.build(leftI, l, mid)
    rightResp := tree.build(rightI, mid+1, r)
    tree.tree[index] = leftResp + rightResp
    return tree.tree[index]
}

// 查询arrs范围queryL到queryR 的结果
func (tree *SegmentTree) Query(queryL, queryR int) (int, error) {
    length := len(tree.a)
    if queryL < 0 || queryL > queryR || queryR >= length {
        return 0, errors.New("index is illegal")
    }
    return tree.queryrange(0, 0, length-1, queryL, queryR), nil
}

// 在以index为根的线段树中[l...r]范围里，搜索区间[queryL...queryR]的值
func (tree *SegmentTree) queryrange(index, l, r, queryL, queryR int) int {
    if l == queryL && r == queryR {
        return tree.tree[index]
    }
    leftI := leftChild(index)
    rightI := leftI + 1
    mid := l + (r-l)/2
    if queryL > mid {
        return tree.queryrange(rightI, mid+1, r, queryL, queryR)
    }
    if queryR <= mid {
        return tree.queryrange(leftI, l, mid, queryL, queryR)
    }
    leftResp := tree.queryrange(leftI, l, mid, queryL, mid)
    rightResp := tree.queryrange(rightI, mid+1, r, mid+1, queryR)
    return leftResp + rightResp
}

// 更新a中索引k的值为v
func (tree *SegmentTree) Change(k, v int) {
    length := len(tree.a)
    if k < 0 || k >= length {
        return
    }
    tree.set(0, 0, length-1, k, v)
}

// 在以treeIndex为根的线段树中更新index的值为e
func (tree *SegmentTree) set(treeIndex, l, r, k, v int) {
    if l == r {
        tree.tree[treeIndex] = v
        return
    }
    leftI := leftChild(treeIndex)
    rightI := leftI + 1
    midI := l + (r-l)/2
    if k > midI {
        tree.set(rightI, midI+1, r, k, v)
    } else {
        tree.set(leftI, l, midI, k, v)
    }
    tree.tree[treeIndex] = tree.tree[leftI] + tree.tree[rightI]
}

func (tree *SegmentTree) Print() {
    fmt.Println(tree.tree)
}

```
